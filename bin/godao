#!/usr/bin/env python


from collections import OrderedDict
import os
import re
import subprocess
import sys

from mako.template import Template
import yaml
import yamlordereddictloader


RE_ID = r"[_a-zA-Z][_a-zA-Z0-9]*"
CRE_NAME = re.compile(r"^{}$".format(RE_ID))

CRE_STR_ANNOTATION = re.compile(r"""
%s
(
    \{{
        str
        \:
        ({id})
        (
            \(
                (?:
                    (?:
                        {id}
                        ,
                    )*
                    {id}
                )?
            \)
        )?
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

CRE_IN_ANNOTATION = re.compile(r"""
\?
(
    \{{
    in
    \:
    (
        {id}
        (?:
            \.
            {id}
        )?
    )
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

CRE_OUT_ANNOTATION = re.compile(r"""
({id})
(
    \{{
    out
    \:
    ({id})
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

KIND_FLAG_NULLABLE = 1
KIND_FLAG_ARRAY = 2

KIND_BOOL          = 1 << 2
KIND_NULL_BOOL     = KIND_BOOL | KIND_FLAG_NULLABLE
KIND_BOOL_ARRAY    = KIND_BOOL | KIND_FLAG_ARRAY
KIND_INT           = 2 << 2
KIND_NULL_INT      = KIND_INT | KIND_FLAG_NULLABLE
KIND_INT_ARRAY     = KIND_INT | KIND_FLAG_ARRAY
KIND_UINT          = 3 << 2
KIND_NULL_UINT     = KIND_UINT | KIND_FLAG_NULLABLE
KIND_UINT_ARRAY    = KIND_UINT | KIND_FLAG_ARRAY
KIND_INT8          = 3 << 2
KIND_NULL_INT8     = KIND_INT8 | KIND_FLAG_NULLABLE
KIND_INT8_ARRAY    = KIND_INT8 | KIND_FLAG_ARRAY
KIND_UINT8         = 4 << 2
KIND_NULL_UINT8    = KIND_UINT8 | KIND_FLAG_NULLABLE
KIND_UINT8_ARRAY   = KIND_UINT8 | KIND_FLAG_ARRAY
KIND_INT16         = 5 << 2
KIND_NULL_INT16    = KIND_INT16 | KIND_FLAG_NULLABLE
KIND_INT16_ARRAY   = KIND_INT16 | KIND_FLAG_ARRAY
KIND_UINT16        = 6 << 2
KIND_NULL_UINT16   = KIND_UINT16 | KIND_FLAG_NULLABLE
KIND_UINT16_ARRAY  = KIND_UINT16 | KIND_FLAG_ARRAY
KIND_INT32         = 7 << 2
KIND_NULL_INT32    = KIND_INT32 | KIND_FLAG_NULLABLE
KIND_INT32_ARRAY   = KIND_INT32 | KIND_FLAG_ARRAY
KIND_UINT32        = 8 << 2
KIND_NULL_UINT32   = KIND_UINT32 | KIND_FLAG_NULLABLE
KIND_UINT32_ARRAY  = KIND_UINT32 | KIND_FLAG_ARRAY
KIND_INT64         = 9 << 2
KIND_NULL_INT64    = KIND_INT64 | KIND_FLAG_NULLABLE
KIND_INT64_ARRAY   = KIND_INT64 | KIND_FLAG_ARRAY
KIND_UINT64        = 10 << 2
KIND_NULL_UINT64   = KIND_UINT64 | KIND_FLAG_NULLABLE
KIND_UINT64_ARRAY  = KIND_UINT64 | KIND_FLAG_ARRAY
KIND_FLOAT32       = 11 << 2
KIND_NULL_FLOAT32  = KIND_FLOAT32 | KIND_FLAG_NULLABLE
KIND_FLOAT32_ARRAY = KIND_FLOAT32 | KIND_FLAG_ARRAY
KIND_FLOAT64       = 12 << 2
KIND_NULL_FLOAT64  = KIND_FLOAT64 | KIND_FLAG_NULLABLE
KIND_FLOAT64_ARRAY = KIND_FLOAT64 | KIND_FLAG_ARRAY
KIND_BYTES         = 13 << 2
KIND_STRING        = 14 << 2
KIND_BYTES_ARRAY   = KIND_BYTES | KIND_FLAG_ARRAY
KIND_NULL_STRING   = KIND_STRING | KIND_FLAG_NULLABLE
KIND_STRING_ARRAY  = KIND_STRING | KIND_FLAG_ARRAY
KIND_TIME          = 15 << 2
KIND_NULL_TIME     = KIND_TIME | KIND_FLAG_NULLABLE
KIND_TIME_ARRAY    = KIND_TIME | KIND_FLAG_ARRAY

TYPES_AND_KINDS = (
    ("bool", KIND_BOOL),
    ("bool*", KIND_NULL_BOOL),
    ("bool[]", KIND_BOOL_ARRAY),
    ("int", KIND_INT),
    ("int*", KIND_NULL_INT),
    ("int[]", KIND_INT_ARRAY),
    ("uint", KIND_UINT),
    ("uint*", KIND_NULL_UINT),
    ("uint[]", KIND_UINT_ARRAY),
    ("int8", KIND_INT8),
    ("int8*", KIND_NULL_INT8),
    ("int8[]", KIND_INT8_ARRAY),
    ("uint8", KIND_UINT8),
    ("uint8*", KIND_NULL_UINT8),
    ("uint8[]", KIND_UINT8_ARRAY),
    ("int16", KIND_INT16),
    ("int16*", KIND_NULL_INT16),
    ("int16[]", KIND_INT16_ARRAY),
    ("uint16", KIND_UINT16),
    ("uint16*", KIND_NULL_UINT16),
    ("uint16[]", KIND_UINT16_ARRAY),
    ("int32", KIND_INT32),
    ("int32*", KIND_NULL_INT32),
    ("int32[]", KIND_INT32_ARRAY),
    ("uint32", KIND_UINT32),
    ("uint32*", KIND_NULL_UINT32),
    ("uint32[]", KIND_UINT32_ARRAY),
    ("int64", KIND_INT64),
    ("int64*", KIND_NULL_INT64),
    ("int64[]", KIND_INT64_ARRAY),
    ("uint64", KIND_UINT64),
    ("uint64*", KIND_NULL_UINT64),
    ("uint64[]", KIND_UINT64_ARRAY),
    ("float32", KIND_FLOAT32),
    ("float32*", KIND_NULL_FLOAT32),
    ("float32[]", KIND_FLOAT32_ARRAY),
    ("float64", KIND_FLOAT64),
    ("float64*", KIND_NULL_FLOAT64),
    ("float64[]", KIND_FLOAT64_ARRAY),
    ("bytes", KIND_BYTES),
    ("bytes[]", KIND_BYTES_ARRAY),
    ("string", KIND_STRING),
    ("string*", KIND_NULL_STRING),
    ("string[]", KIND_STRING_ARRAY),
    ("time", KIND_TIME),
    ("time*", KIND_NULL_TIME),
    ("time[]", KIND_TIME_ARRAY),
)

TYPE_2_KIND = {type_: kind for type_, kind in TYPES_AND_KINDS}
KIND_2_TYPE = {kind: type_ for type_, kind in TYPES_AND_KINDS}

KIND_2_GO_TYPE = {
    KIND_BOOL: "bool",
    KIND_NULL_BOOL: "sql.NullBool",
    KIND_BOOL_ARRAY: "[]bool",
    KIND_INT: "int",
    KIND_NULL_INT: "sql.NullInt64",
    KIND_INT_ARRAY: "[]int",
    KIND_UINT: "uint",
    KIND_NULL_UINT: "sql.NullInt64",
    KIND_UINT_ARRAY: "[]uint",
    KIND_INT8: "int8",
    KIND_NULL_INT8: "sql.NullInt64",
    KIND_INT8_ARRAY: "[]int8",
    KIND_UINT8: "uint8",
    KIND_NULL_UINT8: "sql.NullInt64",
    KIND_UINT8_ARRAY: "[]uint8",
    KIND_INT16: "int16",
    KIND_NULL_INT16: "sql.NullInt64",
    KIND_INT16_ARRAY: "[]int16",
    KIND_UINT16: "uint16",
    KIND_NULL_UINT16: "sql.NullInt64",
    KIND_UINT16_ARRAY: "[]uint16",
    KIND_INT32: "int32",
    KIND_NULL_INT32: "sql.NullInt64",
    KIND_INT32_ARRAY: "[]int32",
    KIND_UINT32: "uint32",
    KIND_NULL_UINT32: "sql.NullInt64",
    KIND_UINT32_ARRAY: "[]uint32",
    KIND_INT64: "int64",
    KIND_NULL_INT64: "sql.NullInt64",
    KIND_INT64_ARRAY: "[]int64",
    KIND_UINT64: "uint64",
    KIND_NULL_UINT64: "sql.NullInt64",
    KIND_UINT64_ARRAY: "[]uint64",
    KIND_FLOAT32: "float32",
    KIND_NULL_FLOAT32: "sql.NullFloat64",
    KIND_FLOAT32_ARRAY: "[]float32",
    KIND_FLOAT64: "float64",
    KIND_NULL_FLOAT64: "sql.NullFloat64",
    KIND_FLOAT64_ARRAY: "[]float64",
    KIND_BYTES: "[]byte",
    KIND_BYTES_ARRAY: "[][]byte",
    KIND_STRING: "string",
    KIND_NULL_STRING: "sql.NullString",
    KIND_STRING_ARRAY: "[]string",
    KIND_TIME: "time.Time",
    KIND_NULL_TIME: "mysql.NullTime",
    KIND_TIME_ARRAY: "[]time.Time",
}


class Config(object):
    @classmethod
    def load(cls, parent, path, raw):
        must_be_dict(path, raw)
        instance = cls(parent, path)
        instance.package_name = must_be_str(path + ["package_name"], raw.get("package_name"))

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                dao_name = k[1:]
                instance.daos[dao_name] = DAOConfig.load(instance, path + [k], dao_name, v)

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.package_name = None
        self.daos = OrderedDict()

    def resolve(self, context):
        for dao in self.daos.values():
            dao.resolve(context)

    def emit_code(self, context):
        code = Template("""\
/*
 * Generated by Godao. DO NOT EDIT!
 */

package ${root.package_name}

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "github.com/go-sql-driver/mysql"
    "github.com/jmoiron/sqlx"
)

var (
    _ = fmt.Sprintf
    _ time.Time
    _ mysql.NullTime
)
""").render(
            root=self,
        )

        for dao in self.daos.values():
            code += dao.emit_code(context)

        code += Template("""\
% for struct_type_name, struct_type_def in context_.struct_type_defs.items():

type ${struct_type_name} struct {
%     for field_name, field_kind in struct_type_def.items():
    ${field_name} ${context_.kind_to_go_type(field_kind)}
%     endfor
}
% endfor
""").render(
            context_=context,
        )

        return code


class DAOConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        path.append("strings")
        raw_strings = must_be_dict(path, raw.get(path[-1], {}))

        for k, v in raw_strings.items():
            if isinstance(k, str) and k.startswith("$"):
                string_name = k[1:]
                instance.strings[string_name] = StringConfig.load(instance, path + [k], string_name, v)

        del path[-1]

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                method_name = k[1:]
                instance.methods[method_name] = MethodConfig.load(instance, path + [k], method_name, v)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.strings = OrderedDict()
        self.methods = OrderedDict()

    def resolve(self, context):
        for string in self.strings.values():
            string.resolve(context)

        for method in self.methods.values():
            method.resolve(context)

    def emit_code(self, context):
        code = Template("""\
% if any(string.value is not None for string in dao.strings.values()):

const (
%     for string in dao.strings.values():
%         if string.value is not None:
   ${make_string_constant_name(dao.name, string.name)} = "${string.value}"
%         endif
%     endfor
)
% endif

type ${dao.name} struct {
    db *sqlx.DB
}

func (self ${dao.name}) Tx(context_ context.Context, txOptions *sql.TxOptions, callback func(${dao.name}Tx) error) error {
    tx, e := self.db.BeginTxx(context_, txOptions)

    if e != nil {
        return e
    }

    txIsCommitted := false

    defer func() {
        if !txIsCommitted {
            tx.Rollback()
        }
    }()

    if e := callback(${dao.name}Tx(tx)); e != nil {
        return e
    }

    if e := tx.Commit(); e != nil {
        return e
    }

    txIsCommitted = true;
    return nil
}

type ${dao.name}Tx *sqlx.Tx

func Make${dao.name}(db *sqlx.DB) ${dao.name} {
    return ${dao.name}{db}
}
""").render(
            dao=self,
            make_string_constant_name=make_string_constant_name,
        )

        for method in self.methods.values():
            code += method.emit_code(context)

        return code


class StringConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        value = raw.get("value")
        maker_func_name = raw.get("maker_func_name")

        if value is None and maker_func_name is None:
            raise InvalidConfigError(path, "either `value` or `maker_func_name` required")

        if value is not None:
            instance.value = must_be_str(path + ["value"], value)

        if maker_func_name is not None:
            instance.maker_func_name = check_name(path + ["maker_func_name"], maker_func_name)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.value = None
        self.maker_func_name = None

    def resolve(self, context):
        pass


class MethodConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        instance.input = InputConfig.load(instance, path + ["input"], raw.get("input"))
        instance.output = OutputConfig.load(instance, path + ["output"], raw.get("output"))
        instance.sql = SQLConfig.load(instance, path + ["sql"], raw.get("sql"))
        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.input = None
        self.output = None
        self.sql = None

    def resolve(self, context):
        self.input.resolve(context)
        self.output.resolve(context)
        self.sql.resolve(context)

    def emit_code(self, context):
        if len(self.output.results) == 0:
            result_zero = "sql.Result{}"
        else:
            if self.output.select_one and not kind_is_struct(self.output.reduced_result_kind):
                result_zero = {
                    KIND_BOOL: "false",
                    KIND_BYTES: "nil",
                    KIND_STRING: "\"\"",
                    KIND_TIME: "time.Time{}",
                }.get(self.output.reduced_result_kind, "0")
            else:
                result_zero = "nil"

        code = Template("""\
<%
    if method.output.reduced_result_kind is None:
        reduced_result_go_type = None
    else:
        reduced_result_go_type = context_.kind_to_go_type(method.output.reduced_result_kind)
%>\\

func (_self ${dao.name}) ${method.name}(context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
sql.Result\\
% else:
${("" if method.output.select_one else "[]") + reduced_result_go_type}\\
% endif
, error) {
    return _self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(_self.db, context_\\
% for param_name in method.input.params.keys():
, ${param_name}\\
% endfor
)
}

func (_self ${dao.name}) ${"tx" + camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else "Tx" + method.name}(\\
tx ${dao.name}Tx, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
sql.Result\\
% else:
${("" if method.output.select_one else "[]") + reduced_result_go_type}\\
% endif
, error) {
    return _self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}((*sqlx.Tx)(tx), context_\\
% for i, param_name in enumerate(method.input.params.keys()):
, ${param_name}\\
% endfor
)
}

func (${dao.name}) do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(\\
${"execer sqlx.ExecerContext" if reduced_result_go_type is None else "queryer sqlx.QueryerContext"}, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
sql.Result\\
% else:
${("" if method.output.select_one else "[]") + reduced_result_go_type}\\
% endif
, error) {
    /*
% for line in method.sql.raw.strip().split("\\n"):
     * ${line}
% endfor
     */
    _query := "${method.sql.text}"
% if len(method.sql.str_annotations) >= 1:
    _query = fmt.Sprintf(_query\\
%     for string_name, param_names in method.sql.str_annotations:
<%        string = dao.strings[string_name] %>\\
%         if param_names is None:
, ${make_string_constant_name(dao.name, string_name)}\\
%         else:
, ${string.maker_func_name}(context_\\
%             if string.value is not None:
, ${make_string_constant_name(dao.name, string_name)}\\
%             endif
%             for param_name in param_names:
, ${param_name}\\
%             endfor
)\\
%         endif
%     endfor
)
% endif
    _args := []interface{}{${", ".join(method.sql.in_annotations)}}
% if method.sql.has_array_query_args:
    _query, _args, _e := sqlx.In(_query, _args...)

    if _e != nil {
        return ${result_zero}, _e
    }

% endif
% if reduced_result_go_type is None:
    return execer.ExecContext(context_, _query, _args...)
% else:
%     if method.output.select_one:
    _row := queryer.QueryRowxContext(context_, _query, _args...)
%         if kind_is_struct(method.output.reduced_result_kind):
    _record := new(${reduced_result_go_type[1:]})

    if _e := _row.Scan(${", ".join("&_record." + result_name for _, result_name in method.sql.out_annotations)}); _e != nil {
%             if method.output.ignore_no_rows:
        if _e == sql.ErrNoRows {
            _e = nil
        }

%             endif
        return ${result_zero}, _e
    }
%         else:
    var _record ${reduced_result_go_type}

    if _e := _row.Scan(&_record); _e != nil {
%             if method.output.ignore_no_rows:
        if _e == sql.ErrNoRows {
            _e = nil
        }

%             endif
        return ${result_zero}, _e
    }
%         endif

    return _record, nil
%     else:
    _rows, _e := queryer.QueryxContext(context_, _query, _args...)

    if _e != nil {
        return ${result_zero}, _e
    }

    _records := []${reduced_result_go_type}(nil)

    for _rows.Next() {
%         if kind_is_struct(method.output.reduced_result_kind):
        _record := new(${reduced_result_go_type[1:]})

        if _e := _rows.Scan(${", ".join("&_record." + result_name for _, result_name in method.sql.out_annotations)}); _e != nil {
            _rows.Close()
            return ${result_zero}, _e
        }
%         else:
        var _record ${reduced_result_go_type}

        if _e := _rows.Scan(&_record); _e != nil {
            _rows.Close()
            return ${result_zero}, _e
        }
%         endif

        _records = append(_records, _record)
    }

    _rows.Close()
    return _records, nil
%     endif
% endif
}
""").render(
            method=self,
            dao=self.parent,
            context_=context,
            result_zero=result_zero,
            kind_is_struct=kind_is_struct,
            is_camel_case=is_camel_case,
            camel_case_to_pascal_case=camel_case_to_pascal_case,
            pascal_case_to_camel_case=pascal_case_to_camel_case,
            make_string_constant_name=make_string_constant_name,
        )

        return code


class InputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            must_be_dict(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    param_name = check_name(path + [k], k[1:])

                    if isinstance(v, OrderedDict):
                        instance.params[param_name] = parse_struct_type_config(path + [k], v)
                    else:
                        instance.params[param_name] = parse_type(path + [k], v)

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.params = OrderedDict()

        self.expanded_params = OrderedDict()

    def resolve(self, context):
        for param_name, maybe_param_kind in tuple(self.params.items()):
            if isinstance(maybe_param_kind, int):
                self.expanded_params[param_name] = maybe_param_kind
            else:
                struct_type_name, struct_type_def = maybe_param_kind
                param_kind = context.define_struct_type(self.path, struct_type_name, struct_type_def)
                self.params[param_name] = param_kind

                for field_name, field_kind in struct_type_def.items():
                    self.expanded_params[param_name + "." + field_name] = field_kind

        method = self.parent
        used_param_names = set()

        for _, param_names in method.sql.str_annotations:
            if param_names is not None:
                used_param_names.update(param_names)

        for param_name in method.sql.in_annotations:
            used_param_names.add(param_name)

        for param_name in set(self.expanded_params.keys()) - used_param_names:
            raise InvalidConfigError(self.path, "param {!r} unused".format(param_name))


class OutputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            must_be_dict(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    result_name = check_name(path + [k], k[1:])
                    instance.results[result_name] = parse_type(path + [k], v)

            if "struct_type_name" in raw:
                instance.struct_type_name = check_name(path + ["struct_type_name"], raw["struct_type_name"])

            instance.select_one = must_be_bool(path + ["select_one"], raw.get("select_one", False))
            instance.ignore_no_rows = must_be_bool(path + ["ignore_no_rows"], raw.get("ignore_no_rows", False))

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.results = OrderedDict()
        self.struct_type_name = None
        self.select_one = None
        self.ignore_no_rows = None

        self.reduced_result_kind = None

    def resolve(self, context):
        method = self.parent
        used_result_names = set()

        for _, result_name in method.sql.out_annotations:
            used_result_names.add(result_name)

        for result_name in set(self.results.keys()) - used_result_names:
            raise InvalidConfigError(self.path, "result {!r} unused".format(result_name))

        for result_name, result_kind in self.results.items():
            if kind_is_array(result_kind):
                raise InvalidConfigError(self.path, "result {!r} should not be array".format(result_name))

        if len(self.results) == 0 and self.struct_type_name is not None:
            raise InvalidConfigError(self.path, "useless struct type name: value={!r}".format(self.struct_type_name))

        if len(self.results) >= 2 and self.struct_type_name is None:
            raise InvalidConfigError(self.path, "missing struct type name")

        if len(self.results) >= 1:
            if self.struct_type_name is None:
                (_, self.reduced_result_kind), = self.results.items()
            else:
                self.reduced_result_kind = context.define_struct_type(self.path, self.struct_type_name, self.results)


class SQLConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        text = must_be_str(path, raw)
        instance = cls(parent, path, raw)

        while True:
            m = CRE_STR_ANNOTATION.search(text)

            if m is None:
                break

            if m.group(3) is None:
                instance.str_annotations.append((m.group(2), None))
            else:
                instance.str_annotations.append((m.group(2), m.group(3)[1:-1].split(",")))

            text = text[:m.start(1)] + text[m.end(1):]

        while True:
            m = CRE_IN_ANNOTATION.search(text)

            if m is None:
                break

            instance.in_annotations.append(m.group(2))
            text = text[:m.start(1)] + text[m.end(1):]

        while True:
            m = CRE_OUT_ANNOTATION.search(text)

            if m is None:
                break

            instance.out_annotations.append((m.group(1), m.group(3)))
            text = text[:m.start(2)] + text[m.end(2):]

        for c in ("{", "}"):
            i = 0

            while True:
                i = text.find(c, i)

                if i < 0:
                    break

                j = i + 1

                while j < len(text):
                    if text[j] != c:
                        break

                    j += 1

                i += (j - i) // 2 * 2

                if i != j:
                    raise InvalidConfigError(path, "bad annotations: value=...{!r}".format(text[i:]))

        text = text.replace("{{", "{").replace("}}", "}")
        text = re.sub(r"\s+", " ", text.strip())
        instance.text = text
        return instance

    def __init__(self, parent, path, raw):
        self.parent = parent
        self.path = path
        self.raw = raw
        self.str_annotations = []
        self.in_annotations = []
        self.out_annotations = []
        self.text = None

        self.has_array_query_args = None

    def resolve(self, context):
        method = self.parent
        dao = method.parent

        for string_name, param_names in self.str_annotations:
            string = dao.strings.get(string_name)

            if string is None:
                raise InvalidConfigError(self.path, "string {!r} undefined".format(string_name))

            if param_names is None:
                if string.maker_func_name is not None:
                    raise InvalidConfigError(self.path, "str:{} => must call with argument list (...)".format(string_name))
            else:
                if string.maker_func_name is None:
                    raise InvalidConfigError(self.path, "str:{} => can not call with argument list ({})".format(string_name, ",".join(param_names)))

                for param_name in param_names:
                    if param_name not in method.input.expanded_params:
                        raise InvalidConfigError(self.path, "param {!r} undefined".format(param_name))

        for param_name in self.in_annotations:
            if param_name not in method.input.expanded_params:
                raise InvalidConfigError(self.path, "param {!r} undefined".format(param_name))

        used_result_names = set()

        for _, result_name in self.out_annotations:
            if result_name not in method.output.results:
                raise InvalidConfigError(self.path, "result {!r} undefined".format(result_name))

            if result_name in used_result_names:
                raise InvalidConfigError(self.path, "result {!r} reused".format(result_name))

            used_result_names.add(result_name)

        for param_name in self.in_annotations:
            param_kind = method.input.expanded_params[param_name]

            if kind_is_array(param_kind):
                self.has_array_query_args = True
                break
        else:
            self.has_array_query_args = False


class Context(object):
    def __init__(self):
        self.struct_type_defs = OrderedDict()
        self._struct_kinds_and_type_digests = {}
        self._struct_kind_2_go_type = {}

    def define_struct_type(self, path, struct_type_name, struct_type_def):
        struct_type_digest = "struct { "

        for field_name, field_kind in struct_type_def.items():
            field_type = KIND_2_TYPE[field_kind]
            struct_type_digest += "{} {}; ".format(field_type, field_name)

        struct_type_digest += "}"
        struct_kind_and_type_digest = self._struct_kinds_and_type_digests.get(struct_type_name)

        if struct_kind_and_type_digest is None:
            self.struct_type_defs[struct_type_name] = struct_type_def
            struct_kind = -len(self.struct_type_defs)
            self._struct_kinds_and_type_digests[struct_type_name] = struct_kind, struct_type_digest
            self._struct_kind_2_go_type[struct_kind] = "*" + struct_type_name
            return struct_kind
        else:
            struct_kind, struct_type_digest2 = struct_kind_and_type_digest

            if struct_type_digest != struct_type_digest2:
                raise InvalidConfigError(path, "struct type {!r} redefined: {!r} != {!r}"
                                               .format(struct_type_name, struct_type_digest, struct_type_digest2))

            return struct_kind

    def kind_to_go_type(self, kind):
        if kind_is_struct(kind):
            return self._struct_kind_2_go_type[kind]
        else:
            return KIND_2_GO_TYPE[kind]


class InvalidConfigError(Exception):
    def __init__(self, path, message):
        self._path = path
        self._message = message

    def __str__(self):
        return "{}: {}".format(".".join(self._path), self._message)


def load_config(config_text):
    raw_config = yaml.load(config_text, yamlordereddictloader.Loader)
    return Config.load(None, [""], raw_config)


def must_be_bool(path, object_):
    if not isinstance(object_, bool):
        raise InvalidConfigError(path, "must be bool, type={!r}".format(type(object_)))

    return object_


def must_be_str(path, object_):
    if not isinstance(object_, str):
        raise InvalidConfigError(path, "must be str, type={!r}".format(type(object_)))

    return object_


def must_be_list(path, object_):
    if not isinstance(object_, list):
        raise InvalidConfigError(path, "must be list, value={!r}".format(type(object_)))

    return object_


def must_be_dict(path, object_):
    if not isinstance(object_, OrderedDict):
        raise InvalidConfigError(path, "must be dict, value={!r}".format(type(object_)))

    return object_


def check_name(path, name):
    must_be_str(path, name)

    if CRE_NAME.match(name) is None:
        raise InvalidConfigError(path, "invalid name, value={!r}".format(name))

    return name


def parse_type(path, type_):
    must_be_str(path, type_)
    kind = TYPE_2_KIND.get(type_)

    if kind is None:
        raise InvalidConfigError(path, "invalid type, value={!r}, excepted_values={!r}".format(type_, [type_ for type_, _ in TYPES_AND_KINDS]))

    return kind


def parse_struct_type_config(path, struct_type_config):
    struct_type_name = check_name(path + ["struct_type_name"], struct_type_config.get("struct_type_name"))
    struct_type_def = OrderedDict()

    for k, v in struct_type_config.items():
        if isinstance(k, str) and k.startswith("$"):
            field_name = check_name(path + [k], k[1:])
            struct_type_def[field_name] = parse_type(path + [k], v)

    return struct_type_name, struct_type_def


def kind_is_array(kind):
    return kind >= 1 and (kind & KIND_FLAG_ARRAY) != 0


def kind_is_struct(kind):
    return kind < 0


def is_camel_case(name):
    return name[0].islower()


def camel_case_to_pascal_case(name):
    return name[0].upper() + name[1:]


def pascal_case_to_camel_case(name):
    i = 1

    while i < len(name):
        if name[i].islower():
            if i == 1:
                return name[0].lower() + name[1:]
            else:
                return name[:i-1].lower() + name[i-1:]

        i += 1
    else:
        return name.lower()

def make_string_constant_name(dao_name, string_name):
    if is_camel_case(string_name):
        if not is_camel_case(dao_name):
            dao_name = pascal_case_to_camel_case(dao_name)

        string_name = camel_case_to_pascal_case(string_name)

    return "{}_{}".format(dao_name, string_name)


def generate_code(config_text):
    config = load_config(config_text)
    context = Context()
    config.resolve(context)
    code = config.emit_code(context)
    code = format_code(code)
    return code


def format_code(code):
    try:
        process = subprocess.Popen("gofmt", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        output, _ = process.communicate(code)

        if process.poll() == os.EX_OK:
            code = output
    except:
        pass

    return code


def main():
    config_text = sys.stdin.read()
    code = generate_code(config_text)
    sys.stdout.write(code)


if __name__ == "__main__":
    main()
