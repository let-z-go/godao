#!/usr/bin/env python


from collections import OrderedDict
import hashlib
import json
import os
import re
import subprocess
import sys

from mako.template import Template
import yaml
import yamlordereddictloader


PY3 = sys.version_info[0] == 3

if PY3:
    INT_MIN = -sys.maxsize - 1
else:
    INT_MIN = -sys.maxint - 1

RE_ID = r"[_a-zA-Z][_a-zA-Z0-9]*"

RE_PARAM_NAME = r"""
{id}
(?:
    \[
        {id}
    \]
)?
(?:
    \.
    {id}
)?
""".format(id=RE_ID)

CRE_NAME = re.compile(r"{}$".format(RE_ID))

CRE_STR_ANNOT = re.compile(r"""
%s
(
    #
    \{{
        str
        \:
        ({id})
        (
            \(
                (?:
                    (?:
                        {param_name}
                        ,
                    )*
                    {param_name}
                )?
            \)
        )?
    \}}
)
""".format(id=RE_ID, param_name=RE_PARAM_NAME).replace("\n", "").replace(" ", ""))

CRE_IN_ANNOT = re.compile(r"""
\?
(
    #
    \{{
    in
    \:
    (
        {param_name}
    )
    \}}
)
""".format(param_name=RE_PARAM_NAME).replace("\n", "").replace(" ", ""))

CRE_OUT_ANNOT = re.compile(r"""
({id})
(
    #
    \{{
    out
    \:
    ({id})
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

KIND_FLAG_NULLABLE = 1
KIND_FLAG_ARRAY = 2

KIND_BOOL          = 1 << 2
KIND_NULL_BOOL     = KIND_BOOL | KIND_FLAG_NULLABLE
KIND_BOOL_ARRAY    = KIND_BOOL | KIND_FLAG_ARRAY
KIND_INT           = 2 << 2
KIND_NULL_INT      = KIND_INT | KIND_FLAG_NULLABLE
KIND_INT_ARRAY     = KIND_INT | KIND_FLAG_ARRAY
KIND_UINT          = 3 << 2
KIND_NULL_UINT     = KIND_UINT | KIND_FLAG_NULLABLE
KIND_UINT_ARRAY    = KIND_UINT | KIND_FLAG_ARRAY
KIND_INT8          = 3 << 2
KIND_NULL_INT8     = KIND_INT8 | KIND_FLAG_NULLABLE
KIND_INT8_ARRAY    = KIND_INT8 | KIND_FLAG_ARRAY
KIND_UINT8         = 4 << 2
KIND_NULL_UINT8    = KIND_UINT8 | KIND_FLAG_NULLABLE
KIND_UINT8_ARRAY   = KIND_UINT8 | KIND_FLAG_ARRAY
KIND_INT16         = 5 << 2
KIND_NULL_INT16    = KIND_INT16 | KIND_FLAG_NULLABLE
KIND_INT16_ARRAY   = KIND_INT16 | KIND_FLAG_ARRAY
KIND_UINT16        = 6 << 2
KIND_NULL_UINT16   = KIND_UINT16 | KIND_FLAG_NULLABLE
KIND_UINT16_ARRAY  = KIND_UINT16 | KIND_FLAG_ARRAY
KIND_INT32         = 7 << 2
KIND_NULL_INT32    = KIND_INT32 | KIND_FLAG_NULLABLE
KIND_INT32_ARRAY   = KIND_INT32 | KIND_FLAG_ARRAY
KIND_UINT32        = 8 << 2
KIND_NULL_UINT32   = KIND_UINT32 | KIND_FLAG_NULLABLE
KIND_UINT32_ARRAY  = KIND_UINT32 | KIND_FLAG_ARRAY
KIND_INT64         = 9 << 2
KIND_NULL_INT64    = KIND_INT64 | KIND_FLAG_NULLABLE
KIND_INT64_ARRAY   = KIND_INT64 | KIND_FLAG_ARRAY
KIND_UINT64        = 10 << 2
KIND_NULL_UINT64   = KIND_UINT64 | KIND_FLAG_NULLABLE
KIND_UINT64_ARRAY  = KIND_UINT64 | KIND_FLAG_ARRAY
KIND_FLOAT32       = 11 << 2
KIND_NULL_FLOAT32  = KIND_FLOAT32 | KIND_FLAG_NULLABLE
KIND_FLOAT32_ARRAY = KIND_FLOAT32 | KIND_FLAG_ARRAY
KIND_FLOAT64       = 12 << 2
KIND_NULL_FLOAT64  = KIND_FLOAT64 | KIND_FLAG_NULLABLE
KIND_FLOAT64_ARRAY = KIND_FLOAT64 | KIND_FLAG_ARRAY
KIND_BYTES         = 13 << 2
KIND_STRING        = 14 << 2
KIND_BYTES_ARRAY   = KIND_BYTES | KIND_FLAG_ARRAY
KIND_NULL_STRING   = KIND_STRING | KIND_FLAG_NULLABLE
KIND_STRING_ARRAY  = KIND_STRING | KIND_FLAG_ARRAY
KIND_TIME          = 15 << 2
KIND_NULL_TIME     = KIND_TIME | KIND_FLAG_NULLABLE
KIND_TIME_ARRAY    = KIND_TIME | KIND_FLAG_ARRAY

TYPES_AND_KINDS = (
    ("bool", KIND_BOOL),
    ("bool*", KIND_NULL_BOOL),
    ("bool[]", KIND_BOOL_ARRAY),
    ("int", KIND_INT),
    ("int*", KIND_NULL_INT),
    ("int[]", KIND_INT_ARRAY),
    ("uint", KIND_UINT),
    ("uint*", KIND_NULL_UINT),
    ("uint[]", KIND_UINT_ARRAY),
    ("int8", KIND_INT8),
    ("int8*", KIND_NULL_INT8),
    ("int8[]", KIND_INT8_ARRAY),
    ("uint8", KIND_UINT8),
    ("uint8*", KIND_NULL_UINT8),
    ("uint8[]", KIND_UINT8_ARRAY),
    ("int16", KIND_INT16),
    ("int16*", KIND_NULL_INT16),
    ("int16[]", KIND_INT16_ARRAY),
    ("uint16", KIND_UINT16),
    ("uint16*", KIND_NULL_UINT16),
    ("uint16[]", KIND_UINT16_ARRAY),
    ("int32", KIND_INT32),
    ("int32*", KIND_NULL_INT32),
    ("int32[]", KIND_INT32_ARRAY),
    ("uint32", KIND_UINT32),
    ("uint32*", KIND_NULL_UINT32),
    ("uint32[]", KIND_UINT32_ARRAY),
    ("int64", KIND_INT64),
    ("int64*", KIND_NULL_INT64),
    ("int64[]", KIND_INT64_ARRAY),
    ("uint64", KIND_UINT64),
    ("uint64*", KIND_NULL_UINT64),
    ("uint64[]", KIND_UINT64_ARRAY),
    ("float32", KIND_FLOAT32),
    ("float32*", KIND_NULL_FLOAT32),
    ("float32[]", KIND_FLOAT32_ARRAY),
    ("float64", KIND_FLOAT64),
    ("float64*", KIND_NULL_FLOAT64),
    ("float64[]", KIND_FLOAT64_ARRAY),
    ("bytes", KIND_BYTES),
    ("bytes[]", KIND_BYTES_ARRAY),
    ("string", KIND_STRING),
    ("string*", KIND_NULL_STRING),
    ("string[]", KIND_STRING_ARRAY),
    ("time", KIND_TIME),
    ("time*", KIND_NULL_TIME),
    ("time[]", KIND_TIME_ARRAY),
)

TYPE_2_KIND = {type_: kind for type_, kind in TYPES_AND_KINDS}
KIND_2_TYPE = {kind: type_ for type_, kind in TYPES_AND_KINDS}

KIND_2_GO_TYPE = {
    KIND_BOOL: "bool",
    KIND_NULL_BOOL: "sql.NullBool",
    KIND_BOOL_ARRAY: "[]bool",
    KIND_INT: "int",
    KIND_NULL_INT: "sql.NullInt64",
    KIND_INT_ARRAY: "[]int",
    KIND_UINT: "uint",
    KIND_NULL_UINT: "sql.NullInt64",
    KIND_UINT_ARRAY: "[]uint",
    KIND_INT8: "int8",
    KIND_NULL_INT8: "sql.NullInt64",
    KIND_INT8_ARRAY: "[]int8",
    KIND_UINT8: "uint8",
    KIND_NULL_UINT8: "sql.NullInt64",
    KIND_UINT8_ARRAY: "[]uint8",
    KIND_INT16: "int16",
    KIND_NULL_INT16: "sql.NullInt64",
    KIND_INT16_ARRAY: "[]int16",
    KIND_UINT16: "uint16",
    KIND_NULL_UINT16: "sql.NullInt64",
    KIND_UINT16_ARRAY: "[]uint16",
    KIND_INT32: "int32",
    KIND_NULL_INT32: "sql.NullInt64",
    KIND_INT32_ARRAY: "[]int32",
    KIND_UINT32: "uint32",
    KIND_NULL_UINT32: "sql.NullInt64",
    KIND_UINT32_ARRAY: "[]uint32",
    KIND_INT64: "int64",
    KIND_NULL_INT64: "sql.NullInt64",
    KIND_INT64_ARRAY: "[]int64",
    KIND_UINT64: "uint64",
    KIND_NULL_UINT64: "sql.NullInt64",
    KIND_UINT64_ARRAY: "[]uint64",
    KIND_FLOAT32: "float32",
    KIND_NULL_FLOAT32: "sql.NullFloat64",
    KIND_FLOAT32_ARRAY: "[]float32",
    KIND_FLOAT64: "float64",
    KIND_NULL_FLOAT64: "sql.NullFloat64",
    KIND_FLOAT64_ARRAY: "[]float64",
    KIND_BYTES: "[]byte",
    KIND_BYTES_ARRAY: "[][]byte",
    KIND_STRING: "string",
    KIND_NULL_STRING: "sql.NullString",
    KIND_STRING_ARRAY: "[]string",
    KIND_TIME: "time.Time",
    KIND_NULL_TIME: "mysql.NullTime",
    KIND_TIME_ARRAY: "[]time.Time",
}


class Config(object):
    @classmethod
    def load(cls, signature, path, raw):
        ensure_dict_type(path, raw)
        instance = cls(signature, path)
        instance.package_name = ensure_str_type(path + ["package_name"], raw.get("package_name"))
        path.append("imports")
        raw_imports = ensure_list_type(path, raw.get(path[-1], []))

        for i, raw_import in enumerate(raw_imports):
            instance.imports.append(ImportConfig.load(instance, path + [i], raw_import))

        del path[-1]

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                dao_name = k[1:]
                instance.daos[dao_name] = DAOConfig.load(instance, path + [k], dao_name, v)

        return instance

    def __init__(self, signature, path):
        self.signature = signature
        self.path = path
        self.package_name = None
        self.imports = []
        self.daos = OrderedDict()

    def resolve(self, context):
        for import_ in self.imports:
            import_.resolve(context)

        for dao in self.daos.values():
            dao.resolve(context)

    def emit_code(self, context):
        code = [None]

        for dao in self.daos.values():
            code.extend(dao.emit_code(context))

        code.append(Template("""\
% for struct_type_name, struct_type_def in context_.struct_type_defs.items():

type ${struct_type_name} struct {
%     for field_name, field_kind in struct_type_def.items():
    ${field_name} ${context_.kind_to_go_type(field_kind)}
%     endfor
}
% endfor
% for func_code in context_.func_codes:

${func_code}
% endfor
""").render(
            context_=context,
        ))

        code[0] = Template("""\
/*
 * Generated by Godao. DO NOT EDIT!
 */

package ${root.package_name}
% if len(context_.imports) >= 1:

import (
% for package_name, package_path_literal in sorted(context_.imports, key=lambda x: x[1]):
%     if package_name is None:
    ${package_path_literal}
%     else:
    ${package_name} ${package_path_literal}
%     endif
% endfor
)
% endif
""").render(
            root=self,
            context_=context,
        )

        return code


class ImportConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        ensure_type(path, raw, str, list)
        instance = cls(parent, path)

        if isinstance(raw, str):
            instance.package_path = raw
        else:
            if len(raw) != 2:
                error(path, "must be of length 2")

            instance.package_name = check_name(path + [0], raw[0])
            instance.package_path = ensure_str_type(path + [1], raw[1])

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.package_name = None
        self.package_path = None

    def resolve(self, context):
        context.add_import(self.package_name, self.package_path)


class DAOConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        ensure_dict_type(path, raw)
        instance = cls(parent, path, name)
        path.append("strings")
        raw_strings = ensure_dict_type(path, raw.get(path[-1], OrderedDict()))

        for k, v in raw_strings.items():
            if isinstance(k, str) and k.startswith("$"):
                string_name = k[1:]
                instance.strings[string_name] = StringConfig.load(instance, path + [k], string_name, v)

        del path[-1]

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                method_name = k[1:]
                instance.methods[method_name] = MethodConfig.load(instance, path + [k], method_name, v)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.strings = OrderedDict()
        self.methods = OrderedDict()

    def resolve(self, context):
        for string in self.strings.values():
            string.resolve(context)

        for method in self.methods.values():
            method.resolve(context)

    def emit_code(self, context):
        code = [Template("""\
% if any(string.value is not None for string in dao.strings.values()):

const (
%     for string in dao.strings.values():
%         if string.value is not None:
   ${make_string_constant_name(dao.name, string.name)} = "${string.value}"
%         endif
%     endfor
)
% endif

type ${dao.name} struct {
    db *sqlx.DB
}

func (self ${dao.name}) Tx(context_ context.Context, txOptions *sql.TxOptions, callback func(${dao.name}Tx) error) error {
    tx, e := self.db.BeginTxx(context_, txOptions)

    if e != nil {
        return e
    }

    txIsCommitted := false

    defer func() {
        if !txIsCommitted {
            tx.Rollback()
        }
    }()

    if e := callback(${dao.name}Tx(tx)); e != nil {
        return e
    }

    if e := tx.Commit(); e != nil {
        return e
    }

    txIsCommitted = true;
    return nil
}

type ${dao.name}Tx *sqlx.Tx

func Make${dao.name}(db *sqlx.DB) ${dao.name} {
    return ${dao.name}{db}
}
""").render(
            dao=self,
            make_string_constant_name=make_string_constant_name,
        )]

        context.add_import(None, "context")
        context.add_import(None, "database/sql")
        context.add_import(None, "github.com/jmoiron/sqlx")

        for method in self.methods.values():
            code.extend(method.emit_code(context))

        return code


class StringConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        ensure_dict_type(path, raw)
        instance = cls(parent, path, name)
        value = raw.get("value")
        maker_func_name = raw.get("maker_func_name")

        if value is None and maker_func_name is None:
            error(path, "either `value` or `maker_func_name` required")

        if value is not None:
            instance.value = ensure_str_type(path + ["value"], value)

        if maker_func_name is not None:
            instance.maker_func_name = check_name(path + ["maker_func_name"], maker_func_name)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.value = None
        self.maker_func_name = None

    def resolve(self, context):
        pass


class MethodConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        ensure_dict_type(path, raw)
        instance = cls(parent, path, name)
        instance.input = InputConfig.load(instance, path + ["input"], raw.get("input"))
        instance.output = OutputConfig.load(instance, path + ["output"], raw.get("output"))
        instance.sql = SQLConfig.load(instance, path + ["sql"], raw.get("sql"))
        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.input = None
        self.output = None
        self.sql = None

    def resolve(self, context):
        self.input.resolve(context)
        self.output.resolve(context)
        self.sql.resolve(context)

    def emit_code(self, context):
        class Counter(Visitor):
            def __init__(self):
                super(Counter, self).__init__()
                self.max_number_of_str_annots = 0
                self.max_number_of_in_annots = 0
                self.max_number_of_out_annots = 0
                self.max_query_size = 0
                self._str_annot_count = 0
                self._in_annot_count = 0
                self._out_annot_count = 0
                self._query_size = 0

            def visit_if_statement(self, statement):
                backup = self._str_annot_count, self._in_annot_count, self._out_annot_count, self._query_size

                for _, then_body in statement.conds_and_then_bodies:
                    then_body.accept_visit(self)
                    self._str_annot_count, self._in_annot_count, self._out_annot_count, self._query_size = backup

                if statement.else_body is not None:
                    statement.else_body.accept_visit(self)

                self._str_annot_count, self._in_annot_count, self._out_annot_count, self._query_size = \
                    self.max_number_of_str_annots, \
                    self.max_number_of_in_annots, \
                    self.max_number_of_out_annots, \
                    self.max_query_size
                return False

            def visit_for_statement(self, statement):
                backup = self._str_annot_count, self._in_annot_count, self._out_annot_count, self._query_size
                statement.body.accept_visit(self)
                n = statement.estimated_loop_count - 1

                if n >= 1:
                    str_annot_count, in_annot_count, out_annot_count, query_size = backup
                    self._str_annot_count += n * (self._str_annot_count - str_annot_count)
                    self._in_annot_count += n * (self._in_annot_count - in_annot_count)
                    self._out_annot_count += n * (self._out_annot_count - out_annot_count)
                    self._query_size += n * (self._query_size - query_size)

                    if self._str_annot_count > self.max_number_of_str_annots:
                        self.max_number_of_str_annots = self._str_annot_count

                    if self._in_annot_count > self.max_number_of_in_annots:
                        self.max_number_of_in_annots = self._in_annot_count

                    if self._out_annot_count > self.max_number_of_out_annots:
                        self.max_number_of_out_annots = self._out_annot_count

                    if self._query_size > self.max_query_size:
                        self.max_query_size = self._query_size

                return False

            def visit_text_statement(self, statement):
                self._str_annot_count += len(statement.str_annots)
                self._in_annot_count += len(statement.in_annots)
                self._out_annot_count += len(statement.out_annots)
                self._query_size += statement.lines_size

                if self._str_annot_count > self.max_number_of_str_annots:
                    self.max_number_of_str_annots = self._str_annot_count

                if self._in_annot_count > self.max_number_of_in_annots:
                    self.max_number_of_in_annots = self._in_annot_count

                if self._out_annot_count > self.max_number_of_out_annots:
                    self.max_number_of_out_annots = self._out_annot_count

                if self._query_size > self.max_query_size:
                    self.max_query_size = self._query_size

                return True

        counter = Counter()
        self.sql.program.accept_visit(counter)
        method = self
        dao = method.parent

        if self.output.reduced_result_kind is None:
            reduced_result_go_type = None
        else:
            reduced_result_go_type = context.kind_to_go_type(self.output.reduced_result_kind)

        if reduced_result_go_type is None:
            if self.output.as_result is None:
                result_zero = "nil"
            else:
                result_zero = "0"
        else:
            if self.output.is_array or kind_is_customized(self.output.reduced_result_kind):
                result_zero = "nil"
            else:
                result_zero = {
                    KIND_BOOL: "false",
                    KIND_BYTES: "nil",
                    KIND_STRING: "\"\"",
                    KIND_TIME: "time.Time{}",
                }.get(self.output.reduced_result_kind, "0")

        class CodeGenerator(Visitor):
            def __init__(self, line_prefix, indent):
                self._line_prefix = line_prefix
                self._indent = indent
                self._lines = []

            def get_output(self):
                return "\n".join(self._lines)

            def visit_program(self, program):
                self._output_line("_buffer1 := [{}]byte{{}}".format(counter.max_query_size))
                self._output_line("_raw_query := _buffer1[:0]")

                if counter.max_number_of_str_annots >= 1:
                    self._output_line("_buffer2 := [{}]interface{{}}{{}}".format(counter.max_number_of_str_annots))
                    self._output_line("_query_substrs := _buffer2[:0]")

                if counter.max_number_of_in_annots >= 1:
                    self._output_line("_buffer3 := [{}]interface{{}}{{}}".format(counter.max_number_of_in_annots))
                    self._output_line("_args := _buffer3[:0]")

                    if method.sql.has_array_query_args:
                        self._output_line("_expand_args := false")

                if counter.max_number_of_out_annots >= 1:
                    if kind_is_customized(method.output.reduced_result_kind):
                        self._output_line("var _buffer4 {}".format(reduced_result_go_type[1:]))
                        self._output_line("_record := &_buffer4")
                    else:
                        self._output_line("var _record {}".format(reduced_result_go_type))

                    self._output_line("_buffer5 := [{}]interface{{}}{{}}".format(counter.max_number_of_out_annots))
                    self._output_line("_results := _buffer5[:0]")

                for statement in program.body:
                    statement.accept_visit(self)

                if counter.max_number_of_str_annots == 0:
                    self._output_line("_query := string(_raw_query)")
                else:
                    self._output_line("_query := fmt.Sprintf(string(_raw_query), _query_substrs...)")
                    context.add_import(None, "fmt")

                    if method.sql.has_array_query_args:
                        self._output_lines(Template("""\
if _expand_args {
    var _e error
    _query, _args, _e = sqlx.In(_query, _args...)
    if _e != nil {
        return ${result_zero}, _e
    }
}
""").render(
                            result_zero=result_zero,
                        ))

                if counter.max_number_of_in_annots == 0:
                    args_part = ""
                else:
                    args_part = ", _args..."

                if reduced_result_go_type is None:
                    if method.output.as_result is None:
                        self._output_line("return execer.ExecContext(context_, _query{})".format(args_part))
                    else:
                        self._output_lines(Template("""\
_result, _e := execer.ExecContext(context_, _query${args_part})
if _e != nil {
    return ${result_zero}, _e
}
return _result.${"LastInsertId" if as_result == "last_insert_id" else "RowsAffected"}()
""").render(
                            args_part=args_part,
                            result_zero=result_zero,
                            as_result=method.output.as_result,
                        ))
                else:
                    if method.output.is_array:
                        self._output_lines(Template("""\
_rows, _e := queryer.QueryxContext(context_, _query${args_part})
if _e != nil {
    return ${result_zero}, _e
}
_records := []${reduced_result_go_type}(nil)
for _rows.Next() {
    if _e := _rows.Scan(_results...); _e != nil {
        _rows.Close()
        return ${result_zero}, _e
    }
""").render(
                            args_part=args_part,
                            result_zero=result_zero,
                            reduced_result_go_type=reduced_result_go_type,
                        ))

                        if kind_is_customized(method.output.reduced_result_kind):
                            self._output_lines(Template("""\
    _record_copy := new(${reduced_result_go_type[1:]})
    *_record_copy = *_record
    _records = append(_records, _record_copy)
""").render(
                                reduced_result_go_type=reduced_result_go_type
                            ))
                        else:
                            self._output_line("    _records = append(_records, _record)")

                        self._output_lines("""\
}
_rows.Close()
return _records, nil
""")
                    else:
                        self._output_line("if _e := queryer.QueryRowxContext(context_, _query{}).Scan(_results...); _e != nil {{".format(args_part))

                        if method.output.ignore_no_rows:
                            self._output_lines("""\
    if _e == sql.ErrNoRows {
        _e = nil
    }
""")

                        self._output_lines(Template("""\
    return ${result_zero}, _e
}
return _record, nil
""").render(
                            result_zero=result_zero,
                        ))

                return False

            def visit_if_statement(self, statement):
                cond, then_body = statement.conds_and_then_bodies[0]
                self._output_line("if {} {{".format(cond))
                then_body.accept_visit(self)

                for cond, then_body in statement.conds_and_then_bodies[1:]:
                    self._output_line("}} else if {} {{".format(cond))
                    then_body.accept_visit(self)

                if statement.else_body is not None:
                    self._output_line("} else {")
                    statement.else_body.accept_visit(self)

                self._output_line("}")
                return False

            def visit_for_statement(self, statement):
                self._output_line("for {} {{".format(statement.cond))
                statement.body.accept_visit(self)
                self._output_line("}")
                return False

            def visit_error_statement(self, statement):
                self._output_line("return {}, {}".format(result_zero, statement.expr))

            def visit_block_statement(self, statement):
                self._line_prefix += self._indent

                for statement2 in statement.body:
                    statement2.accept_visit(self)

                self._line_prefix = self._line_prefix[:-len(self._indent)]
                return False

            def visit_trim_suffix_statement(self, statement):
                func_name = context.define_func("trimSuffix", """\
func ${func_name}(rawQuery []byte, suffix string) []byte {
    n := len(rawQuery)
    i := n

Loop:
    for i >= 1 {
        switch rawQuery[i-1] {
            case '\\t', '\\n', '\\v', '\\f', '\\r', ' ':
            default:
                break Loop
        }

        i--
    }

    if i >= 1 && bytes.HasSuffix(rawQuery[:i], []byte(suffix)) {
        j := i - len(suffix)

        for i < n {
            rawQuery[j] = rawQuery[i]
            i++
            j++
        }

        rawQuery = rawQuery[:j]
    }

    return rawQuery
}
""")

                context.add_import(None, "bytes")
                self._output_line("_raw_query = {}(_raw_query, {})".format(func_name, statement.suffix_literal))

            def visit_text_statement(self, statement):
                self._output_line("_raw_query = append(_raw_query, {}...)".format(statement.lines_literal))

                if len(statement.str_annots) >= 1:
                    query_substrs = []

                    for string_name, param_names in statement.str_annots:
                        if param_names is None:
                            query_substr = make_string_constant_name(dao.name, string_name)
                        else:
                            string = dao.strings[string_name]
                            query_substr = string.maker_func_name + "(context_"

                            if string.value is not None:
                                query_substr += ", " + make_string_constant_name(dao.name, string_name)

                            for param_name in param_names:
                                query_substr += ", " + param_name

                            query_substr += ")"

                        query_substrs.append(query_substr)

                    self._output_line("_query_substrs = append(_query_substrs, {})".format(", ".join(query_substrs)))

                if len(statement.in_annots) >= 1:
                    self._output_line("_args = append(_args, {})".format(", ".join(statement.in_annots)))

                    for param_name in statement.in_annots:
                        param_kind = method.input.expanded_params[param_name]

                        if kind_is_array(param_kind):
                            self._output_line("_expand_args = true")
                            break

                if len(statement.out_annots) >= 1:
                    if kind_is_customized(method.output.reduced_result_kind):
                        results = ("&_record." + result_name for _, result_name in statement.out_annots)
                        self._output_line("_results = append(_results, {})".format(", ".join(results)))
                    else:
                        self._output_line("_results = append(_results, &_record)")

                return False

            def _output_line(self, line):
                self._lines.append(self._line_prefix + line)

            def _output_lines(self, lines):
                self._lines.extend(self._line_prefix + line for line in lines.split("\n")[:-1])

        code_generator = CodeGenerator("    ", "    ")
        self.sql.program.accept_visit(code_generator)

        code = [Template("""\

func (_self ${dao.name}) ${method.name}(context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
${"sql.Result" if method.output.as_result is None else "int64"}\\
% else:
${("[]" if method.output.is_array else "") + reduced_result_go_type}\\
% endif
, error) {
    return _self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(_self.db, context_\\
% for param_name in method.input.params.keys():
, ${param_name}\\
% endfor
)
}

func (_self ${dao.name}) ${"tx" + camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else "Tx" + method.name}(\\
tx ${dao.name}Tx, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
${"sql.Result" if method.output.as_result is None else "int64"}\\
% else:
${("[]" if method.output.is_array else "") + reduced_result_go_type}\\
% endif
, error) {
    return _self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}((*sqlx.Tx)(tx), context_\\
% for i, param_name in enumerate(method.input.params.keys()):
, ${param_name}\\
% endfor
)
}

func (${dao.name}) do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(\\
${"execer sqlx.ExecerContext" if reduced_result_go_type is None else "queryer sqlx.QueryerContext"}, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${context_.kind_to_go_type(param_kind)}\\
% endfor
) (\\
% if reduced_result_go_type is None:
${"sql.Result" if method.output.as_result is None else "int64"}\\
% else:
${("[]" if method.output.is_array else "") + reduced_result_go_type}\\
% endif
, error) {
% for line in method.sql.raw.split("\\n"):
     // ${line}
% endfor
${impl_code}
}
""").render(
            method=self,
            dao=self.parent,
            context_=context,
            reduced_result_go_type=reduced_result_go_type,
            is_camel_case=is_camel_case,
            camel_case_to_pascal_case=camel_case_to_pascal_case,
            impl_code=code_generator.get_output(),
        )]

        context.add_import(None, "context")
        context.add_import(None, "github.com/jmoiron/sqlx")

        if reduced_result_go_type is None:
            context.add_import(None, "database/sql")

        return code


class InputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            ensure_dict_type(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    param_name = check_name(path + [k], k[1:])
                    ensure_type(path + [k], v, str, dict)

                    if isinstance(v, str):
                        instance.params[param_name] = parse_type(path + [k], v)
                    else:
                        struct_type_name, struct_type_def = parse_struct_type_config(path + [k], v)
                        is_array = ensure_bool_type(path + [k, "is_array"], v.get("is_array", False))
                        instance.params[param_name] = struct_type_name, struct_type_def, is_array

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.params = OrderedDict()

        self.expanded_params = {}

    def resolve(self, context):
        method = self.parent
        used_param_names = set()

        for _, param_names in method.sql.str_annots:
            if param_names is not None:
                used_param_names.update(param_names)

        used_param_names.update(method.sql.in_annots)

        for param_name, maybe_param_kind in tuple(self.params.items()):
            if isinstance(maybe_param_kind, int):
                param_kind = maybe_param_kind

                if kind_is_array(param_kind):
                    n = 0

                    if param_name in used_param_names:
                        self.expanded_params[param_name] = param_kind
                        n += 1

                    cre_sub_param_name = re.compile(r"{}\[.+\]$".format(param_name))
                    element_kind = array_element_kind(param_kind)

                    for used_param_name in used_param_names:
                        if cre_sub_param_name.match(used_param_name) is not None:
                            self.expanded_params[used_param_name] = element_kind
                            n += 1

                    if n == 0:
                        if re.search(r"(^|\W){}(\[.+\])?(\W|$)".format(param_name), method.sql.embedded_code) is None:
                            warn(self.path, "param {!r} and {!r} unused".format(param_name, param_name + "[i]"))
                else:
                    if param_name in used_param_names:
                        self.expanded_params[param_name] = param_kind
                    else:
                        if re.search(r"(^|\W){}(\W|$)".format(param_name), method.sql.embedded_code) is None:
                            warn(self.path, "param {!r} unused".format(param_name))
            else:
                struct_type_name, struct_type_def, is_array = maybe_param_kind
                param_kind = context.define_struct_type(self.path, struct_type_name, struct_type_def)

                if is_array:
                    param_kind = context.define_struct_array_type(param_kind, struct_type_name)
                    self.params[param_name] = param_kind

                    for field_name, field_kind in struct_type_def.items():
                        cre_sub_param_name = re.compile(r"{}\[.+\]\.{}$".format(param_name, field_name))
                        n = 0

                        for used_param_name in used_param_names:
                            if cre_sub_param_name.match(used_param_name) is not None:
                                self.expanded_params[used_param_name] = field_kind
                                n += 1

                        if n == 0:
                            if re.search(r"(^|\W){}\[.+\]\.{}(\W|$)".format(param_name, field_name), method.sql.embedded_code) is None:
                                warn(self.path, "param {!r} unused".format(param_name + "[i]." + field_name))
                else:
                    self.params[param_name] = param_kind

                    for field_name, field_kind in struct_type_def.items():
                        sub_param_name = param_name + "." + field_name

                        if sub_param_name in used_param_names:
                            self.expanded_params[sub_param_name] = field_kind
                        else:
                            if re.search(r"(^|\W){}(\W|$)".format(sub_param_name), method.sql.embedded_code) is None:
                                warn(self.path, "param {!r} unused".format(sub_param_name))


class OutputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            ensure_dict_type(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    result_name = check_name(path + [k], k[1:])
                    instance.results[result_name] = parse_type(path + [k], v)

            if "struct_type_name" in raw:
                instance.struct_type_name = check_name(path + ["struct_type_name"], raw["struct_type_name"])

            instance.is_array = ensure_bool_type(path + ["is_array"], raw.get("is_array", False))
            instance.ignore_no_rows = ensure_bool_type(path + ["ignore_no_rows"], raw.get("ignore_no_rows", False))

            if "as_result" in raw:
                instance.as_result = ensure_value(path + ["as_result"], raw["as_result"], "last_insert_id", "rows_affected")

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.results = OrderedDict()
        self.struct_type_name = None
        self.is_array = None
        self.ignore_no_rows = None
        self.as_result = None

        self.reduced_result_kind = None

    def resolve(self, context):
        method = self.parent
        used_result_names = set()

        for _, result_name in method.sql.out_annots:
            used_result_names.add(result_name)

        for result_name in set(self.results.keys()) - used_result_names:
            warn(self.path, "result {!r} unused".format(result_name))

        for result_name, result_kind in self.results.items():
            if kind_is_array(result_kind):
                error(self.path, "result {!r} should not be array".format(result_name))

        if len(self.results) == 0 and self.struct_type_name is not None:
            warn(self.path, "useless `struct_type_name`")
            self.struct_type_name = None

        if len(self.results) >= 2 and self.struct_type_name is None:
            error(self.path, "missing `struct_type_name`")

        if len(self.results) >= 1:
            if self.struct_type_name is None:
                (_, self.reduced_result_kind), = self.results.items()
            else:
                self.reduced_result_kind = context.define_struct_type(self.path, self.struct_type_name, self.results)


class SQLConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        raw = ensure_str_type(path, raw).rstrip()
        instance = cls(parent, path, raw)
        instance.program = Preprocessor(path, raw).get_program()
        embedded_code = []

        class Collector(Visitor):
            def __init__(self):
                super(Collector, self).__init__()

            def visit_if_statement(self, statement):
                for cond, _ in statement.conds_and_then_bodies:
                    embedded_code.append(cond)

                return True

            def visit_for_statement(self, statement):
                embedded_code.append(statement.cond)
                return True

            def visit_text_statement(self, statement):
                instance.str_annots.extend(statement.str_annots)
                instance.in_annots.extend(statement.in_annots)
                instance.out_annots.extend(statement.out_annots)
                return True

        instance.program.accept_visit(Collector())
        instance.embedded_code = "\n".join(embedded_code)
        return instance

    def __init__(self, parent, path, raw):
        self.parent = parent
        self.path = path
        self.raw = raw
        self.program = None
        self.str_annots = []
        self.in_annots = []
        self.out_annots = []
        self.embedded_code = None

        self.has_array_query_args = None

    def resolve(self, context):
        method = self.parent
        dao = method.parent

        for string_name, param_names in self.str_annots:
            string = dao.strings.get(string_name)

            if string is None:
                error(self.path, "string {!r} undefined".format(string_name))

            if param_names is None:
                if string.maker_func_name is not None:
                    error(self.path, "str:{} => must call with argument list (...)".format(string_name))
            else:
                if string.maker_func_name is None:
                    error(self.path, "str:{} => can not call with argument list ({})".format(string_name, ",".join(param_names)))

                for param_name in param_names:
                    if param_name not in method.input.expanded_params:
                        error(self.path, "param {!r} undefined".format(param_name))

        for param_name in self.in_annots:
            if param_name not in method.input.expanded_params:
                error(self.path, "param {!r} undefined".format(param_name))

        used_result_names = set()

        for _, result_name in self.out_annots:
            if result_name not in method.output.results:
                error(self.path, "result {!r} undefined".format(result_name))

            if result_name in used_result_names:
                error(self.path, "result {!r} reused".format(result_name))

            used_result_names.add(result_name)

        for param_name in self.in_annots:
            param_kind = method.input.expanded_params[param_name]

            if kind_is_array(param_kind):
                self.has_array_query_args = True
                break
        else:
            self.has_array_query_args = False


class Preprocessor(object):
    def __init__(self, path, source):
        self._path = path
        self._lines = source.split("\n")
        self._next_line_index = 0

    def get_program(self):
        program = Program()

        while True:
            _, ok = self._peek_line()

            if not ok:
                return program

            program.body.append(self._get_statement())

    def _get_statement(self):
        line, _ = self._peek_line()

        if line.startswith("#"):
            match = re.match(r"#\s*if", line)

            if match is not None:
                return self._get_if_statement()

            match = re.match(r"#\s*for", line)

            if match is not None:
                return self._get_for_statement()

            match = re.match(r"#\s*error", line)

            if match is not None:
                return self._get_error_statement()

            match = re.match(r"#\s*trim-suffix", line)

            if match is not None:
                return self._get_trim_suffix_statement()

            self._skip_line()
            self._abort("unknown or unexpected directive")
        else:
            return self._get_text_statement()

    def _get_if_statement(self):
        statement = IfStatement()
        line = self._read_line()
        match = re.match(r"#\s*if\s+([^\s].*?)\s*$", line)

        if match is None:
            self._abort("#if ... directive expected")

        statement.conds_and_then_bodies.append((
            match.group(1),
            self._get_block_statement(r"#\s*(else|elif|endif)")
        ))

        line, _ = self._peek_line()

        while True:
            match = re.match(r"#\s*elif\s+([^\s].*?)\s*$", line)

            if match is None:
                if re.match(r"#\s*elif", line) is not None:
                    self._abort("#elif ... directive expected")

                break

            self._skip_line()

            statement.conds_and_then_bodies.append((
                match.group(1),
                self._get_block_statement(r"#\s*(else|elif|endif)")
            ))

            line, _ = self._peek_line()

        if re.match(r"#\s*else\s*$", line) is None:
            if re.match(r"#\s*else", line) is not None:
                self._abort("#else directive expected")
        else:
            self._skip_line()
            statement.else_body = self._get_block_statement(r"#\s*endif")
            line, _ = self._peek_line()

        if re.match(r"#\s*endif\s*$", self._read_line()) is None:
            self._abort("#endif directive expected")

        return statement

    def _get_for_statement(self):
        statement = ForStatement()
        line = self._read_line()
        match = re.match(r"#\s*for(\(\d+\))?\s+([^\s].*?)\s*$", line)

        if match is None:
            self._abort("#for ... directive expected")

        if match.group(1) is None:
            statement.estimated_loop_count = 1
        else:
            statement.estimated_loop_count = int(match.group(1)[1:-1])

        statement.cond = match.group(2)
        statement.body = self._get_block_statement(r"#\s*endfor")

        if re.match(r"#\s*endfor\s*$", self._read_line()) is None:
            self._abort("#endfor directive expected")

        return statement

    def _get_error_statement(self):
        statement = ErrorStatement()
        line = self._read_line()
        match = re.match(r"#\s*error\s+([^\s].*?)\s*$", line)

        if match is None:
            self._abort("#error ... directive expected")

        statement.expr = match.group(1)
        return statement

    def _get_block_statement(self, stop_line_pattern):
        statement = BlockStatement()

        while True:
            line, _ = self._peek_line()

            if re.match(stop_line_pattern, line) is not None:
                return statement

            statement.body.append(self._get_statement())

    def _get_trim_suffix_statement(self):
        statement = TrimSuffixStatement()
        line = self._read_line()
        match = re.match(r"#\s*trim-suffix\s+([^\s].*?)\s*$", line)

        if match is None:
            self._abort("#trim-suffix ... directive expected")

        statement.suffix_literal = quote_string(match.group(1))
        return statement

    def _get_text_statement(self):
        statement = TextStatement()
        line = self._read_line()
        lines = []
        lines_size = 0

        while True:
            while True:
                match = CRE_STR_ANNOT.search(line)

                if match is None:
                    break

                string_name = match.group(2)

                if match.group(3) is None:
                    param_names = None
                else:
                    param_names = match.group(3)[1:-1].split(",")

                statement.str_annots.append((string_name, param_names))
                line = line[:match.start(1)] + line[match.end(1):]

            while True:
                match = CRE_IN_ANNOT.search(line)

                if match is None:
                    break

                param_name = match.group(2)
                statement.in_annots.append(param_name)
                line = line[:match.start(1)] + line[match.end(1):]

            while True:
                match = CRE_OUT_ANNOT.search(line)

                if match is None:
                    break

                column_name = match.group(1)
                result_name = match.group(3)
                statement.out_annots.append((column_name, result_name))
                line = line[:match.start(2)] + line[match.end(2):]

            i = 0

            while True:
                i = line.find("#", i)

                if i < 0:
                    break

                if i == len(line) - 1 or line[i + 1] != "#":
                    self._abort("bad annotation: value=...{!r}".format(line[i:]))

                i += 2

            line = line.replace("##", "#")
            lines.append(line)

            if PY3:
                lines_size += len(line.encode())
            else:
                lines_size += len(line)

            line, ok = self._peek_line()

            if not ok or line.startswith("#"):
                break

            self._skip_line()

        statement.lines_literal = quote_string("\n".join(lines) + "\n")
        statement.lines_size = lines_size + len(lines)
        return statement

    def _read_line(self):
        if self._next_line_index == len(self._lines):
            self._abort("end of file")

        sub_lines = []

        while True:
            sub_line = self._lines[self._next_line_index]

            if not sub_line.endswith("\\"):
                sub_lines.append(sub_line)
                self._next_line_index += 1
                return "".join(sub_lines)

            sub_lines.append(sub_line[:-1])
            self._next_line_index += 1

            if self._next_line_index == len(self._lines):
                self._abort("end of file")

    def _peek_line(self):
        next_line_index = self._next_line_index

        if next_line_index == len(self._lines):
            return "", False

        sub_lines = []

        while True:
            sub_line = self._lines[next_line_index]

            if not sub_line.endswith("\\"):
                sub_lines.append(sub_line)
                return "".join(sub_lines), True

            sub_lines.append(sub_line[:-1])
            next_line_index += 1

            if next_line_index == len(self._lines):
                self._next_line_index = next_line_index
                self._abort("end of file")


    def _skip_line(self):
        while True:
            if self._next_line_index == len(self._lines):
                return

            if not self._lines[self._next_line_index].endswith("\\"):
                self._next_line_index += 1
                return

            self._next_line_index += 1

    def _abort(self, message):
        error(self._path, "line {}: {}".format(self._next_line_index, message))


class Program(object):
    def __init__(self):
        self.body = []

    def accept_visit(self, visitor):
        if visitor.visit_program(self):
            for statement in self.body:
                statement.accept_visit(visitor)


class IfStatement(object):
    def __init__(self):
        self.conds_and_then_bodies = []
        self.else_body = None

    def accept_visit(self, visitor):
        if visitor.visit_if_statement(self):
            for _, then_body in self.conds_and_then_bodies:
                then_body.accept_visit(visitor)

            if self.else_body is not None:
                self.else_body.accept_visit(visitor)


class ForStatement(object):
    def __init__(self):
        self.estimated_loop_count = None
        self.cond = None
        self.body = None

    def accept_visit(self, visitor):
        if visitor.visit_for_statement(self):
            self.body.accept_visit(visitor)


class ErrorStatement(object):
    def __init__(self):
        self.expr = None

    def accept_visit(self, visitor):
        visitor.visit_error_statement(self)


class BlockStatement(object):
    def __init__(self):
        self.body = []

    def accept_visit(self, visitor):
        if visitor.visit_block_statement(self):
            for statement in self.body:
                statement.accept_visit(visitor)


class TrimSuffixStatement(object):
    def __init__(self):
        self.suffix = None

    def accept_visit(self, visitor):
        visitor.visit_trim_suffix_statement(self)


class TextStatement(object):
    def __init__(self):
        self.str_annots = []
        self.in_annots = []
        self.out_annots = []
        self.lines = None
        self.lines_size = None

    def accept_visit(self, visitor):
        visitor.visit_text_statement(self)


class Visitor(object):
    def visit_program(self, program):
        return True

    def visit_if_statement(self, statement):
        return True

    def visit_for_statement(self, statement):
        return True

    def visit_error_statement(self, statement):
        return True

    def visit_block_statement(self, statement):
        return True

    def visit_trim_suffix_statement(self, statement):
        return True

    def visit_text_statement(self, statement):
        return True


class Context(object):
    def __init__(self, config_signature):
        self.imports = set()
        self.struct_type_defs = OrderedDict()
        self.func_codes = []
        self._config_signature = config_signature
        self._struct_kinds_and_type_digests = {}
        self._customized_kind_2_go_type = {}
        self._func_id_2_name = {}

    def add_import(self, package_name, package_path):
        self.imports.add((package_name, quote_string(package_path)))

    def define_struct_type(self, path, struct_type_name, struct_type_def):
        struct_type_digest = "struct { "

        for field_name, field_kind in struct_type_def.items():
            field_type = KIND_2_TYPE[field_kind]
            struct_type_digest += "{} {}; ".format(field_type, field_name)

        struct_type_digest += "}"
        struct_kind_and_type_digest = self._struct_kinds_and_type_digests.get(struct_type_name)

        if struct_kind_and_type_digest is None:
            self.struct_type_defs[struct_type_name] = struct_type_def
            struct_kind = INT_MIN | (len(self.struct_type_defs) << 2)
            self._struct_kinds_and_type_digests[struct_type_name] = struct_kind, struct_type_digest
            self._customized_kind_2_go_type[struct_kind] = "*" + struct_type_name
            return struct_kind
        else:
            struct_kind, struct_type_digest2 = struct_kind_and_type_digest

            if struct_type_digest != struct_type_digest2:
                error(path, "struct type {!r} redefined: {!r} != {!r}".format(struct_type_name, struct_type_digest, struct_type_digest2))

            return struct_kind

    def define_struct_array_type(self, struct_kind, struct_type_name):
        struct_array_kind = struct_kind | KIND_FLAG_ARRAY
        self._customized_kind_2_go_type[struct_array_kind] = "[]" + struct_type_name
        return struct_array_kind

    def kind_to_go_type(self, kind):
        if kind_is_customized(kind):
            return self._customized_kind_2_go_type[kind]
        else:
            {
                KIND_TIME: lambda: self.add_import(None, "time"),
                KIND_NULL_TIME: lambda: self.add_import(None, "github.com/go-sql-driver/mysql"),
                KIND_TIME_ARRAY: lambda: self.add_import(None, "time"),
            }.get(kind, lambda: None)()

            return KIND_2_GO_TYPE[kind]

    def define_func(self, func_id, func_code):
        func_name = self._func_id_2_name.get(func_id)

        if func_name is not None:
            return func_name

        func_name = func_id + "_" + self._config_signature
        self._func_id_2_name[func_id] = func_name
        self.func_codes.append(Template(func_code).render(func_name=func_name))
        return func_name


class InvalidConfigError(Exception):
    def __init__(self, path, message):
        self._path = path
        self._message = message

    def __str__(self):
        return "{}: {}".format(self._path, self._message)


warning_count = 0


def load_config(config_text):
    sha1 = hashlib.sha1()

    if PY3:
        sha1.update(config_text.encode())
    else:
        sha1.update(config_text)

    raw_config = yaml.load(config_text, yamlordereddictloader.Loader)
    return Config.load(sha1.hexdigest(), [""], raw_config)


def ensure_bool_type(path, value):
    return ensure_type(path, value, bool)


def ensure_str_type(path, value):
    return ensure_type(path, value, str)


def ensure_list_type(path, value):
    return ensure_type(path, value, list)


def ensure_dict_type(path, value):
    return ensure_type(path, value, dict)


def ensure_type(path, value, *types):
    for type_ in types:
        if isinstance(value, type_):
            return value

    message = "must be type {!r}".format(types[0].__name__)

    for type_ in types[1:]:
        message += " or {!r}".format(type_.__name__)

    message += ", type={!r}".format(type(value).__name__)
    error(path, message)


def ensure_value(path, value, *values):
    for value2 in values:
        if value2 == value:
            return value

    message = "must be value {!r}".format(values[0])

    for value2 in values[1:]:
        message += " or {!r}".format(value2)

    message += ", value={!r}".format(value)
    error(path, message)


def check_name(path, name):
    ensure_str_type(path, name)

    if CRE_NAME.match(name) is None:
        error(path, "invalid name, value={!r}".format(name))

    return name


def parse_type(path, type_):
    ensure_str_type(path, type_)
    kind = TYPE_2_KIND.get(type_)

    if kind is None:
        error(path, "invalid type, value={!r}, excepted_values={!r}".format(type_, [type_ for type_, _ in TYPES_AND_KINDS]))

    return kind


def parse_struct_type_config(path, struct_type_config):
    struct_type_name = check_name(path + ["struct_type_name"], struct_type_config.get("struct_type_name"))
    struct_type_def = OrderedDict()

    for k, v in struct_type_config.items():
        if isinstance(k, str) and k.startswith("$"):
            field_name = check_name(path + [k], k[1:])
            struct_type_def[field_name] = parse_type(path + [k], v)

    return struct_type_name, struct_type_def


def kind_is_array(kind):
    return kind & KIND_FLAG_ARRAY != 0


def array_element_kind(kind):
    return kind & ~KIND_FLAG_ARRAY


def kind_is_customized(kind):
    return kind < 0


def is_camel_case(name):
    return name[0].islower()


def camel_case_to_pascal_case(name):
    return name[0].upper() + name[1:]


def pascal_case_to_camel_case(name):
    i = 1

    while i < len(name):
        if name[i].islower():
            if i == 1:
                return name[0].lower() + name[1:]
            else:
                return name[:i-1].lower() + name[i-1:]

        i += 1
    else:
        return name.lower()

def make_string_constant_name(dao_name, string_name):
    if is_camel_case(string_name):
        if not is_camel_case(dao_name):
            dao_name = pascal_case_to_camel_case(dao_name)

        string_name = camel_case_to_pascal_case(string_name)

    return "{}_{}".format(dao_name, string_name)


def quote_string(string):
    return json.dumps(string)


def generate_code(config_text):
    config = load_config(config_text)
    context = Context(config.signature)
    config.resolve(context)
    code = "".join(config.emit_code(context))
    code = format_code(code)
    return code


def format_code(code):
    try:
        process = subprocess.Popen("gofmt", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        output, _ = process.communicate(code)

        if process.poll() == os.EX_OK:
            code = output
    except:
        pass

    return code


def error(path, message):
    raise InvalidConfigError(dump_path(path), message)


def warn(path, message):
    global warning_count
    sys.stderr.write("godao: WARNING: {}: {}\n".format(dump_path(path), message))
    warning_count += 1


def dump_path(path):
    path = path[:]
    i = 0

    for j in range(len(path)):
        x = path[j]

        if isinstance(x, int):
            path[i-1] += "[{}]".format(x)
        else:
            path[i] = x
            i += 1

    return ".".join(path[:i])


def main():
    config_text = sys.stdin.read()

    try:
        code = generate_code(config_text)
    except InvalidConfigError as e:
        sys.stderr.write("godao: ERROR: {}\n".format(e))
        sys.exit(1)

    sys.stdout.write(code)

    if warning_count >= 1:
        sys.exit(1)


main()
