#!/usr/bin/env python


from collections import OrderedDict
import os
import re
import subprocess
import sys

from mako.template import Template
import yaml
import yamlordereddictloader


RE_ID = r"[_a-zA-Z][_a-zA-Z0-9]*"
CRE_NAME = re.compile(r"^{}$".format(RE_ID))

CRE_STR_ANNOTATION = re.compile(r"""
%s
(
    \{{
        str
        \:
        ({id})
        (
            \(
                (?:
                    (?:
                        {id}
                        ,
                    )*
                    {id}
                )?
            \)
        )?
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

CRE_IN_ANNOTATION = re.compile(r"""
\?
(
    \{{
    in
    \:
    ({id})
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

CRE_OUT_ANNOTATION = re.compile(r"""
({id})
(
    \{{
    out
    \:
    ({id})
    \}}
)
""".format(id=RE_ID).replace("\n", "").replace(" ", ""))

KIND_BOOL = 1
KIND_BOOL_ARRAY = -1
KIND_INT = 2
KIND_INT_ARRAY = -2
KIND_INT8 = 2
KIND_INT8_ARRAY = -2
KIND_UINT8 = 3
KIND_UINT8_ARRAY = -3
KIND_INT16 = 4
KIND_INT16_ARRAY = -4
KIND_UINT16 = 5
KIND_UINT16_ARRAY = -5
KIND_INT32 = 6
KIND_INT32_ARRAY = -6
KIND_UINT32 = 7
KIND_UINT32_ARRAY = -7
KIND_INT64 = 8
KIND_INT64_ARRAY = -8
KIND_UINT64 = 9
KIND_UINT64_ARRAY = -9
KIND_FLOAT32 = 10
KIND_FLOAT32_ARRAY = -10
KIND_FLOAT64 = 11
KIND_FLOAT64_ARRAY = -11
KIND_BYTES = 12
KIND_BYTES_ARRAY = -12
KIND_STRING = 13
KIND_STRING_ARRAY = -13
KIND_TIME = 14
KIND_TIME_ARRAY = -14

TYPES_AND_KINDS = (
    ("bool", KIND_BOOL),
    ("bool[]", KIND_BOOL_ARRAY),
    ("int", KIND_INT),
    ("int[]", KIND_INT_ARRAY),
    ("int8", KIND_INT8),
    ("int8[]", KIND_INT8_ARRAY),
    ("uint8", KIND_UINT8),
    ("uint8[]", KIND_UINT8_ARRAY),
    ("int16", KIND_INT16),
    ("int16[]", KIND_INT16_ARRAY),
    ("uint16", KIND_UINT16),
    ("uint16[]", KIND_UINT16_ARRAY),
    ("int32", KIND_INT32),
    ("int32[]", KIND_INT32_ARRAY),
    ("uint32", KIND_UINT32),
    ("uint32[]", KIND_UINT32_ARRAY),
    ("int64", KIND_INT64),
    ("int64[]", KIND_INT64_ARRAY),
    ("uint64", KIND_UINT64),
    ("uint64[]", KIND_UINT64_ARRAY),
    ("float32", KIND_FLOAT32),
    ("float32[]", KIND_FLOAT32_ARRAY),
    ("float64", KIND_FLOAT64),
    ("float64[]", KIND_FLOAT64_ARRAY),
    ("bytes", KIND_BYTES),
    ("bytes[]", KIND_BYTES_ARRAY),
    ("string", KIND_STRING),
    ("string[]", KIND_STRING_ARRAY),
    ("time", KIND_TIME),
    ("time[]", KIND_TIME_ARRAY),
)

TYPE_2_KIND = {type_: kind for type_, kind in TYPES_AND_KINDS}
KIND_2_TYPE = {kind: type_ for type_, kind in TYPES_AND_KINDS}

KIND_2_GO_TYPE = {
    KIND_BOOL: "bool",
    KIND_BOOL_ARRAY: "[]bool",
    KIND_INT: "int",
    KIND_INT_ARRAY: "[]int",
    KIND_INT8: "int8",
    KIND_INT8_ARRAY: "[]int8",
    KIND_UINT8: "uint8",
    KIND_UINT8_ARRAY: "[]uint8",
    KIND_INT16: "int16",
    KIND_INT16_ARRAY: "[]int16",
    KIND_UINT16: "uint16",
    KIND_UINT16_ARRAY: "[]uint16",
    KIND_INT32: "int32",
    KIND_INT32_ARRAY: "[]int32",
    KIND_UINT32: "uint32",
    KIND_UINT32_ARRAY: "[]uint32",
    KIND_INT64: "int64",
    KIND_INT64_ARRAY: "[]int64",
    KIND_UINT64: "uint64",
    KIND_UINT64_ARRAY: "[]uint64",
    KIND_FLOAT32: "float32",
    KIND_FLOAT32_ARRAY: "[]float32",
    KIND_FLOAT64: "float64",
    KIND_FLOAT64_ARRAY: "[]float64",
    KIND_BYTES: "[]byte",
    KIND_BYTES_ARRAY: "[][]byte",
    KIND_STRING: "string",
    KIND_STRING_ARRAY: "[]string",
    KIND_TIME: "time.Time",
    KIND_TIME_ARRAY: "[]time.Time",
}


class Config(object):
    @classmethod
    def load(cls, parent, path, raw):
        must_be_dict(path, raw)
        instance = cls(parent, path)
        instance.package_name = must_be_str(path + ["package_name"], raw.get("package_name"))

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                dao_name = k[1:]
                instance.daos[dao_name] = DAOConfig.load(instance, path + [k], dao_name, v)

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.package_name = None
        self.daos = OrderedDict()

    def resolve(self, context):
        for dao in self.daos.values():
            dao.resolve(context)

    def emit_code(self):
        code = """\
/*
 * Generated by Godao. DO NOT EDIT!
 */

package {package_name}

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    "github.com/jmoiron/sqlx"
)

var (
    _ = fmt.Sprintf
    _ time.Time
)
""".format(
            package_name=self.package_name,
        )

        for dao in self.daos.values():
            code += dao.emit_code()

        return code


class DAOConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        path.append("strings")
        raw_strings = must_be_dict(path, raw.get(path[-1], {}))

        for k, v in raw_strings.items():
            if isinstance(k, str) and k.startswith("$"):
                string_name = k[1:]
                instance.strings[string_name] = StringConfig.load(instance, path + [k], string_name, v)

        del path[-1]

        for k, v in raw.items():
            if isinstance(k, str) and k.startswith("$"):
                method_name = k[1:]
                instance.methods[method_name] = MethodConfig.load(instance, path + [k], method_name, v)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.strings = OrderedDict()
        self.methods = OrderedDict()

    def resolve(self, context):
        for string in self.strings.values():
            string.resolve(context)

        for method in self.methods.values():
            method.resolve(context)

    def emit_code(self):
        code = Template("""\
% if any(string.value is not None for string in dao.strings.values()):

const (
%     for string in dao.strings.values():
%         if string.value is not None:
   ${make_string_constant_name(dao.name, string.name)} = "${string.value}"
%         endif
%     endfor
)
% endif

type ${dao.name} struct {
    db *sqlx.DB
}

func (self ${dao.name}) Tx(context_ context.Context, txOptions *sql.TxOptions, callback func(${dao.name}Tx) error) error {
    tx, e := self.db.BeginTxx(context_, txOptions)

    if e != nil {
        return e
    }

    txIsCommitted := false

    defer func() {
        if !txIsCommitted {
            tx.Rollback()
        }
    }()

    if e := callback(${dao.name}Tx(tx)); e != nil {
        return e
    }

    if e := tx.Commit(); e != nil {
        return e
    }

    txIsCommitted = true;
    return nil
}

type ${dao.name}Tx *sqlx.Tx

func Make${dao.name}(db *sqlx.DB) ${dao.name} {
    return ${dao.name}{db}
}
""").render(
            dao=self,
            make_string_constant_name=make_string_constant_name,
        )

        for method in self.methods.values():
            code += method.emit_code()

        return code


class StringConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        value = raw.get("value")
        maker_func_name = raw.get("maker_func_name")

        if value is None and maker_func_name is None:
            raise InvalidConfigError(path, "either `value` or `maker_func_name` required")

        if value is not None:
            instance.value = must_be_str(path + ["value"], value)

        if maker_func_name is not None:
            instance.maker_func_name = check_name(path + ["maker_func_name"], maker_func_name)

        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.value = None
        self.maker_func_name = None

    def resolve(self, context):
        pass


class MethodConfig(object):
    @classmethod
    def load(cls, parent, path, name, raw):
        check_name(path, name)
        must_be_dict(path, raw)
        instance = cls(parent, path, name)
        instance.input = InputConfig.load(instance, path + ["input"], raw.get("input"))
        instance.output = OutputConfig.load(instance, path + ["output"], raw.get("output"))
        instance.sql = SQLConfig.load(instance, path + ["sql"], raw.get("sql"))
        return instance

    def __init__(self, parent, path, name):
        self.parent = parent
        self.path = path
        self.name = name
        self.input = None
        self.output = None
        self.sql = None

    def resolve(self, context):
        self.input.resolve(context)
        self.output.resolve(context)
        self.sql.resolve(context)

    def emit_code(self):
        if len(self.output.results) == 0:
            result_zero = "sql.Result{}"
        else:
            if self.output.struct_type_name is None and self.output.select_one:
                result_zero = {
                    KIND_BOOL: "false",
                    KIND_BYTES: "nil",
                    KIND_STRING: "\"\"",
                    KIND_TIME: "time.Time{}",
                }.get(self.output.result[1], "0")
            else:
                result_zero = "nil"

        code = Template("""\
% if method.output.struct_type_name is not None and not method.output.struct_type_is_reused:

type ${method.output.struct_type_name} struct {
%     for result_name, result_kind in method.output.results.items():
    ${result_name} ${KIND_2_GO_TYPE[result_kind]}
%     endfor
}
% endif

func (self ${method.parent.name}) ${method.name}(context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${KIND_2_GO_TYPE[param_kind]}\\
% endfor
) (\\
% if len(method.output.results) == 0:
sql.Result\\
% else:
%     if method.output.struct_type_name is None:
${("" if method.output.select_one else "[]") + KIND_2_GO_TYPE[method.output.result[1]]}\\
%     else:
${("" if method.output.select_one else "[]") + "*" + method.output.struct_type_name}\\
%     endif
% endif
, error) {
    return self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(self.db, context_\\
% for param_name in method.input.params.keys():
, ${param_name}\\
% endfor
)
}

func (self ${method.parent.name}) ${"tx" + camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else "Tx" + method.name}(\\
tx ${method.parent.name}Tx, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${KIND_2_GO_TYPE[param_kind]}\\
% endfor
) (\\
% if len(method.output.results) == 0:
sql.Result\\
% else:
%     if method.output.struct_type_name is None:
${("" if method.output.select_one else "[]") + KIND_2_GO_TYPE[method.output.result[1]]}\\
%     else:
${("" if method.output.select_one else "[]") + "*" + method.output.struct_type_name}\\
%     endif
% endif
, error) {
    return self.do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}((*sqlx.Tx)(tx), context_\\
% for i, param_name in enumerate(method.input.params.keys()):
, ${param_name}\\
% endfor
)
}

func (${method.parent.name}) do${camel_case_to_pascal_case(method.name) if is_camel_case(method.name) else method.name}(\\
${"execer sqlx.ExecerContext" if len(method.output.results) == 0 else "queryer sqlx.QueryerContext"}, context_ context.Context\\
% for param_name, param_kind in method.input.params.items():
, ${param_name} ${KIND_2_GO_TYPE[param_kind]}\\
% endfor
) (\\
% if len(method.output.results) == 0:
sql.Result\\
% else:
%     if method.output.struct_type_name is None:
${("" if method.output.select_one else "[]") + KIND_2_GO_TYPE[method.output.result[1]]}\\
%     else:
${("" if method.output.select_one else "[]") + "*" + method.output.struct_type_name}\\
%     endif
% endif
, error) {
    /*
% for line in method.sql.raw.strip().split("\\n"):
     * ${line}
% endfor
     */
    query := "${method.sql.text}"
% if len(method.sql.str_annotations) >= 1:
    query = fmt.Sprintf(query\\
%     for string_name, param_names in method.sql.str_annotations:
<%        string = method.parent.strings[string_name] %>\\
%         if param_names is None:
, ${make_string_constant_name(method.parent.name, string_name)}\\
%         else:
, ${string.maker_func_name}(context_\\
%             if string.value is not None:
, ${make_string_constant_name(method.parent.name, string_name)}\\
%             endif
%             for param_name in param_names:
, ${param_name}\\
%             endfor
)\\
%         endif
%     endfor
)
% endif
    args := []interface{}{${", ".join(method.sql.in_annotations)}}
% if method.sql.has_array_query_args:
    query, args, e := sqlx.In(query, args...)

    if e != nil {
        return ${result_zero}, e
    }

% endif
% if len(method.output.results) == 0:
    return execer.ExecContext(context_, query, args...)
% else:
%     if method.output.select_one:
    row := queryer.QueryRowxContext(context_, query, args...)
%         if method.output.struct_type_name is None:
    var record ${KIND_2_GO_TYPE[method.output.result[1]]}

    if e := row.Scan(&record); e != nil {
%             if method.output.ignore_no_rows:
        if e == sql.ErrNoRows {
            e = nil
        }

%             endif
        return ${result_zero}, e
    }

    return record, nil
%         else:
    var record ${method.output.struct_type_name}

    if e := row.Scan(${", ".join("&record." + result_name for _, result_name in method.sql.out_annotations)}); e != nil {
%             if method.output.ignore_no_rows:
        if e == sql.ErrNoRows {
            e = nil
        }

%             endif
        return ${result_zero}, e
    }

    return &record, nil
%         endif
%     else:
    rows, e := queryer.QueryxContext(context_, query, args...)

    if e != nil {
        return ${result_zero}, e
    }

%         if method.output.struct_type_name is None:
    records := []${KIND_2_GO_TYPE[method.output.result[1]]}(nil)

    for rows.Next() {
        var record ${KIND_2_GO_TYPE[method.output.result[1]]}

        if e := rows.Scan(&record); e != nil {
            rows.Close()
            return ${result_zero}, e
        }

        records = append(records, record)
    }
%         else:
    records := []*${method.output.struct_type_name}(nil)

    for rows.Next() {
        var record ${method.output.struct_type_name}

        if e := rows.Scan(${", ".join("&record." + result_name for _, result_name in method.sql.out_annotations)}); e != nil {
            rows.Close()
            return ${result_zero}, e
        }

        records = append(records, &record)
    }
%         endif

    rows.Close()
    return records, nil
%     endif
% endif
}
""").render(
            KIND_2_GO_TYPE=KIND_2_GO_TYPE,
            method=self,
            result_zero=result_zero,
            is_camel_case=is_camel_case,
            camel_case_to_pascal_case=camel_case_to_pascal_case,
            pascal_case_to_camel_case=pascal_case_to_camel_case,
            make_string_constant_name=make_string_constant_name,
        )


        if len(self.output.results) == 0:
            pass
        else:
            if self.output.struct_type_name is None:
                pass
            else:
                pass

        return code


class InputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            must_be_dict(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    param_name = check_name(path + [k], k[1:])
                    instance.params[param_name] = parse_type(path + [k], v)

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.params = OrderedDict()

    def resolve(self, context):
        method = self.parent
        used_param_names = set()

        for _, param_names in method.sql.str_annotations:
            if param_names is not None:
                used_param_names.update(param_names)

        for param_name in method.sql.in_annotations:
            used_param_names.add(param_name)

        for param_name in set(self.params.keys()) - used_param_names:
            raise InvalidConfigError(self.path, "param {!r} unused".format(param_name))


class OutputConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        instance = cls(parent, path)

        if raw is not None:
            must_be_dict(path, raw)

            for k, v in raw.items():
                if isinstance(k, str) and k.startswith("$"):
                    result_name = check_name(path + [k], k[1:])
                    instance.results[result_name] = parse_type(path + [k], v)

            if "struct_type_name" in raw:
                instance.struct_type_name = check_name(path + ["struct_type_name"], raw["struct_type_name"])

            instance.select_one = must_be_bool(path + ["select_one"], raw.get("select_one", False))
            instance.ignore_no_rows = must_be_bool(path + ["ignore_no_rows"], raw.get("ignore_no_rows", False))

        return instance

    def __init__(self, parent, path):
        self.parent = parent
        self.path = path
        self.results = OrderedDict()
        self.struct_type_name = None
        self.select_one = None
        self.ignore_no_rows = None

        self.result = None
        self.struct_type_is_reused = None

    def resolve(self, context):
        method = self.parent
        used_result_names = set()

        for _, result_name in method.sql.out_annotations:
            used_result_names.add(result_name)

        for result_name in set(self.results.keys()) - used_result_names:
            raise InvalidConfigError(self.path, "result {!r} unused".format(result_name))

        for result_name, result_kind in self.results.items():
            if kind_is_array(result_kind):
                raise InvalidConfigError(self.path, "result {!r} should not be array".format(result_name))

        if len(self.results) == 0 and self.struct_type_name is not None:
            raise InvalidConfigError(self.path, "useless struct type name: value={!r}".format(self.struct_type_name))

        if len(self.results) >= 2 and self.struct_type_name is None:
            raise InvalidConfigError(self.path, "missing struct type name")

        if len(self.results) == 1:
            self.result, = self.results.items()

        if self.struct_type_name is not None:
            struct_digest = "struct { "

            for result_name, result_kind in self.results.items():
                result_type = KIND_2_TYPE[result_kind]
                struct_digest += "{} {}; ".format(result_type, result_name)

            struct_digest += "}"
            struct_digest2 = context.struct_digests.get(self.struct_type_name)
            self.struct_type_is_reused = struct_digest2 is not None

            if self.struct_type_is_reused:
                if struct_digest != struct_digest2:
                    raise InvalidConfigError(self.path, "struct type {!r} redefined: {!r} != {!r}"
                                                        .format(self.struct_type_name, struct_digest, struct_digest2))
            else:
                context.struct_digests[self.struct_type_name] = struct_digest


class SQLConfig(object):
    @classmethod
    def load(cls, parent, path, raw):
        text = must_be_str(path, raw)
        instance = cls(parent, path, raw)

        while True:
            m = CRE_STR_ANNOTATION.search(text)

            if m is None:
                break

            if m.group(3) is None:
                instance.str_annotations.append((m.group(2), None))
            else:
                instance.str_annotations.append((m.group(2), m.group(3)[1:-1].split(",")))

            text = text[:m.start(1)] + text[m.end(1):]

        while True:
            m = CRE_IN_ANNOTATION.search(text)

            if m is None:
                break

            instance.in_annotations.append(m.group(2))
            text = text[:m.start(1)] + text[m.end(1):]

        while True:
            m = CRE_OUT_ANNOTATION.search(text)

            if m is None:
                break

            instance.out_annotations.append((m.group(1), m.group(3)))
            text = text[:m.start(2)] + text[m.end(2):]

        for c in ("{", "}"):
            i = text.find(c)

            if i < 0:
                continue

            j = i + 1

            while j < len(text):
                if text[j] != c:
                    break

                j += 1

            if (j - i) % 2 == 1:
                raise InvalidConfigError(path, "bad annotations: value={!r}".format(text))

        text = text.replace("{{", "{").replace("}}", "}")
        text = re.sub(r"\s+", " ", text.strip())
        instance.text = text
        return instance

    def __init__(self, parent, path, raw):
        self.parent = parent
        self.path = path
        self.raw = raw
        self.str_annotations = []
        self.in_annotations = []
        self.out_annotations = []
        self.text = None

        self.has_array_query_args = None

    def resolve(self, context):
        method = self.parent

        for string_name, param_names in self.str_annotations:
            string = method.parent.strings.get(string_name)

            if string is None:
                raise InvalidConfigError(self.path, "string {!r} undefined".format(string_name))

            if param_names is None:
                if string.maker_func_name is not None:
                    raise InvalidConfigError(self.path, "str:{} => must call with argument list (...)".format(string_name))
            else:
                if string.maker_func_name is None:
                    raise InvalidConfigError(self.path, "str:{} => can not call with argument list ({})".format(string_name, ",".join(param_names)))

                for param_name in param_names:
                    if param_name not in method.input.params:
                        raise InvalidConfigError(self.path, "param {!r} undefined".format(param_name))

        for param_name in self.in_annotations:
            if param_name not in method.input.params:
                raise InvalidConfigError(self.path, "param {!r} undefined".format(param_name))

        used_result_names = set()

        for _, result_name in self.out_annotations:
            if result_name not in method.output.results:
                raise InvalidConfigError(self.path, "result {!r} undefined".format(result_name))

            if result_name in used_result_names:
                raise InvalidConfigError(self.path, "result {!r} reused".format(result_name))

            used_result_names.add(result_name)

        for param_name in self.in_annotations:
            param_kind = method.input.params[param_name]

            if kind_is_array(param_kind):
                self.has_array_query_args = True
                break
        else:
            self.has_array_query_args = False


class ResolutionContext(object):
    def __init__(self):
        self.struct_digests = {}


class InvalidConfigError(Exception):
    def __init__(self, path, message):
        self._path = path
        self._message = message

    def __str__(self):
        return "{}: {}".format(".".join(self._path), self._message)


def load_config(config_text):
    raw_config = yaml.load(config_text, yamlordereddictloader.Loader)
    return Config.load(None, [""], raw_config)


def must_be_bool(path, object_):
    if not isinstance(object_, bool):
        raise InvalidConfigError(path, "must be bool, type={!r}".format(type(object_)))

    return object_


def must_be_str(path, object_):
    if not isinstance(object_, str):
        raise InvalidConfigError(path, "must be str, type={!r}".format(type(object_)))

    return object_


def must_be_list(path, object_):
    if not isinstance(object_, list):
        raise InvalidConfigError(path, "must be list, value={!r}".format(type(object_)))

    return object_


def must_be_dict(path, object_):
    if not isinstance(object_, OrderedDict):
        raise InvalidConfigError(path, "must be dict, value={!r}".format(type(object_)))

    return object_


def check_name(path, name):
    must_be_str(path, name)

    if CRE_NAME.match(name) is None:
        raise InvalidConfigError(path, "invalid name, value={!r}".format(name))

    return name


def parse_type(path, type_):
    must_be_str(path, type_)
    kind = TYPE_2_KIND.get(type_)

    if kind is None:
        raise InvalidConfigError(path, "invalid type, value={!r}, excepted_values={!r}".format(type_, [type_ for type_, _ in TYPES_AND_KINDS]))

    return kind


def kind_is_array(kind):
    return kind < 0


def is_camel_case(name):
    return name[0].islower()


def camel_case_to_pascal_case(name):
    return name[0].upper() + name[1:]


def pascal_case_to_camel_case(name):
    i = 1

    while i < len(name):
        if name[i].islower():
            if i == 1:
                return name[0].lower() + name[1:]
            else:
                return name[:i-1].lower() + name[i-1:]

        i += 1
    else:
        return name.lower()

def make_string_constant_name(dao_name, string_name):
    if is_camel_case(string_name):
        if not is_camel_case(dao_name):
            dao_name = pascal_case_to_camel_case(dao_name)

        string_name = camel_case_to_pascal_case(string_name)

    return "{}_{}".format(dao_name, string_name)


def generate_code(config_text):
    config = load_config(config_text)
    resolution_context = ResolutionContext()
    config.resolve(resolution_context)
    code = format_code(config.emit_code())
    return code


def format_code(code):
    try:
        process = subprocess.Popen("gofmt", stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=True)
        output, _ = process.communicate(code)

        if process.poll() == os.EX_OK:
            code = output
    except:
        pass

    return code


def main():
    config_text = sys.stdin.read()
    code = generate_code(config_text)
    sys.stdout.write(code)


if __name__ == "__main__":
    main()
