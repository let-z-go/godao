# Godao

DAO (Data Access Object) Generator for Go

## Requirements

- python 2/3

## Installation

```bash
pip install -U git+https://github.com/let-z-go/godao
```

## Usage examples

1. Define DAO with YAML (`sample.yaml`):

   ```yaml
   package_name: main

   $UserDAO:
     strings:
       $TableUserInfo:
         maker_func_name: LocateUserInfoTable

     $InsertUserInfo:
       input:
         $appID: string
         $uid: int64
         $nickname: string
         $gender: int8
       sql: |
         INSERT INTO
           `%s{str:TableUserInfo(appID)}` (`uid`, `nickname`, `gender`)
         VALUES
           (?{in:uid}, ?{in:nickname}, ?{in:gender})

     $SelectUserInfo:
       input:
         $appID: string
         $uid: int64
       output: &user_info_struct
         $UID: int64
         $Nickname: string
         $Gender: int8
         struct_type_name: UserInfo
         select_one: true
         ignore_no_rows: true
       sql: |
         SELECT
           `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
         FROM
           `%s{str:TableUserInfo(appID)}`
         WHERE
           `uid` = ?{in:uid}

     $SelectMultiUserInfos:
       input:
         $appID: string
         $uids: int64[]
       output:
         <<: *user_info_struct
         select_one: false
       sql: |
         SELECT
           `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
         FROM
           `%s{str:TableUserInfo(appID)}`
         WHERE
           `uid` IN (?{in:uids})

     $SelectNicknameOfUserInfo:
       input:
         $appID: string
         $uid: int64
       output:
         $nickname: string
         select_one: true
       sql: |
         SELECT
           `nickname{out:nickname}`
         FROM
           `%s{str:TableUserInfo(appID)}`
         WHERE
           `uid` = ?{in:uid}

     $UpdateUserInfo:
       input:
         $appID: string
         $uid: int64
         $args:
           $Nickname: string*
           $Gender: int8*
           struct_type_name: UpdateUserInfoArgs
       sql: |
         UPDATE
           `%s{str:TableUserInfo(appID)}`
         SET
           `nickname` = IFNULL(?{in:args.Nickname}, `nickname`),
           `gender` = IFNULL(?{in:args.Gender}, `gender`)
         WHERE
           `uid` = ?{in:uid}
   ```

2. Generate DAO code

   ```bash
   godao < sample.yaml > sample.go
   ```

3. What you got (`sample.go`):

   ```go
   /*
    * Generated by Godao. DO NOT EDIT!
    */

   package main

   import (
       "context"
       "database/sql"
       "fmt"
       "time"

       "github.com/go-sql-driver/mysql"
       "github.com/jmoiron/sqlx"
   )

   var (
       _ = fmt.Sprintf
       _ time.Time
       _ mysql.NullTime
   )

   type UserDAO struct {
       db *sqlx.DB
   }

   func (self UserDAO) Tx(context_ context.Context, txOptions *sql.TxOptions, callback func(UserDAOTx) error) error {
       tx, e := self.db.BeginTxx(context_, txOptions)

       if e != nil {
           return e
       }

       txIsCommitted := false

       defer func() {
           if !txIsCommitted {
               tx.Rollback()
           }
       }()

       if e := callback(UserDAOTx(tx)); e != nil {
           return e
       }

       if e := tx.Commit(); e != nil {
           return e
       }

       txIsCommitted = true
       return nil
   }

   type UserDAOTx *sqlx.Tx

   func MakeUserDAO(db *sqlx.DB) UserDAO {
       return UserDAO{db}
   }

   func (_self UserDAO) InsertUserInfo(context_ context.Context, appID string, uid int64, nickname string, gender int8) (sql.Result, error) {
       return _self.doInsertUserInfo(_self.db, context_, appID, uid, nickname, gender)
   }

   func (_self UserDAO) TxInsertUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64, nickname string, gender int8) (sql.Result, error) {
       return _self.doInsertUserInfo((*sqlx.Tx)(tx), context_, appID, uid, nickname, gender)
   }

   func (UserDAO) doInsertUserInfo(execer sqlx.ExecerContext, context_ context.Context, appID string, uid int64, nickname string, gender int8) (sql.Result, error) {
       /*
        * INSERT INTO
        *   `%s{str:TableUserInfo(appID)}` (`uid`, `nickname`, `gender`)
        * VALUES
        *   (?{in:uid}, ?{in:nickname}, ?{in:gender})
        */
       _query := "INSERT INTO `%s` (`uid`, `nickname`, `gender`) VALUES (?, ?, ?)"
       _query = fmt.Sprintf(_query, LocateUserInfoTable(context_, appID))
       _args := []interface{}{uid, nickname, gender}
       return execer.ExecContext(context_, _query, _args...)
   }

   func (_self UserDAO) SelectUserInfo(context_ context.Context, appID string, uid int64) (*UserInfo, error) {
       return _self.doSelectUserInfo(_self.db, context_, appID, uid)
   }

   func (_self UserDAO) TxSelectUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64) (*UserInfo, error) {
       return _self.doSelectUserInfo((*sqlx.Tx)(tx), context_, appID, uid)
   }

   func (UserDAO) doSelectUserInfo(queryer sqlx.QueryerContext, context_ context.Context, appID string, uid int64) (*UserInfo, error) {
       /*
        * SELECT
        *   `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
        * FROM
        *   `%s{str:TableUserInfo(appID)}`
        * WHERE
        *   `uid` = ?{in:uid}
        */
       _query := "SELECT `uid`, `nickname`, `gender` FROM `%s` WHERE `uid` = ?"
       _query = fmt.Sprintf(_query, LocateUserInfoTable(context_, appID))
       _args := []interface{}{uid}
       _row := queryer.QueryRowxContext(context_, _query, _args...)
       _record := new(UserInfo)

       if _e := _row.Scan(&_record.UID, &_record.Nickname, &_record.Gender); _e != nil {
           if _e == sql.ErrNoRows {
               _e = nil
           }

           return nil, _e
       }

       return _record, nil
   }

   func (_self UserDAO) SelectMultiUserInfos(context_ context.Context, appID string, uids []int64) ([]*UserInfo, error) {
       return _self.doSelectMultiUserInfos(_self.db, context_, appID, uids)
   }

   func (_self UserDAO) TxSelectMultiUserInfos(tx UserDAOTx, context_ context.Context, appID string, uids []int64) ([]*UserInfo, error) {
       return _self.doSelectMultiUserInfos((*sqlx.Tx)(tx), context_, appID, uids)
   }

   func (UserDAO) doSelectMultiUserInfos(queryer sqlx.QueryerContext, context_ context.Context, appID string, uids []int64) ([]*UserInfo, error) {
       /*
        * SELECT
        *   `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
        * FROM
        *   `%s{str:TableUserInfo(appID)}`
        * WHERE
        *   `uid` IN (?{in:uids})
        */
       _query := "SELECT `uid`, `nickname`, `gender` FROM `%s` WHERE `uid` IN (?)"
       _query = fmt.Sprintf(_query, LocateUserInfoTable(context_, appID))
       _args := []interface{}{uids}
       _query, _args, _e := sqlx.In(_query, _args...)

       if _e != nil {
           return nil, _e
       }

       _rows, _e := queryer.QueryxContext(context_, _query, _args...)

       if _e != nil {
           return nil, _e
       }

       _records := []*UserInfo(nil)

       for _rows.Next() {
           _record := new(UserInfo)

           if _e := _rows.Scan(&_record.UID, &_record.Nickname, &_record.Gender); _e != nil {
               _rows.Close()
               return nil, _e
           }

           _records = append(_records, _record)
       }

       _rows.Close()
       return _records, nil
   }

   func (_self UserDAO) SelectNicknameOfUserInfo(context_ context.Context, appID string, uid int64) (string, error) {
       return _self.doSelectNicknameOfUserInfo(_self.db, context_, appID, uid)
   }

   func (_self UserDAO) TxSelectNicknameOfUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64) (string, error) {
       return _self.doSelectNicknameOfUserInfo((*sqlx.Tx)(tx), context_, appID, uid)
   }

   func (UserDAO) doSelectNicknameOfUserInfo(queryer sqlx.QueryerContext, context_ context.Context, appID string, uid int64) (string, error) {
       /*
        * SELECT
        *   `nickname{out:nickname}`
        * FROM
        *   `%s{str:TableUserInfo(appID)}`
        * WHERE
        *   `uid` = ?{in:uid}
        */
       _query := "SELECT `nickname` FROM `%s` WHERE `uid` = ?"
       _query = fmt.Sprintf(_query, LocateUserInfoTable(context_, appID))
       _args := []interface{}{uid}
       _row := queryer.QueryRowxContext(context_, _query, _args...)
       var _record string

       if _e := _row.Scan(&_record); _e != nil {
           return "", _e
       }

       return _record, nil
   }

   func (_self UserDAO) UpdateUserInfo(context_ context.Context, appID string, uid int64, args *UpdateUserInfoArgs) (sql.Result, error) {
       return _self.doUpdateUserInfo(_self.db, context_, appID, uid, args)
   }

   func (_self UserDAO) TxUpdateUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64, args *UpdateUserInfoArgs) (sql.Result, error) {
       return _self.doUpdateUserInfo((*sqlx.Tx)(tx), context_, appID, uid, args)
   }

   func (UserDAO) doUpdateUserInfo(execer sqlx.ExecerContext, context_ context.Context, appID string, uid int64, args *UpdateUserInfoArgs) (sql.Result, error) {
       /*
        * UPDATE
        *   `%s{str:TableUserInfo(appID)}`
        * SET
        *   `nickname` = IFNULL(?{in:args.Nickname}, `nickname`),
        *   `gender` = IFNULL(?{in:args.Gender}, `gender`)
        * WHERE
        *   `uid` = ?{in:uid}
        */
       _query := "UPDATE `%s` SET `nickname` = IFNULL(?, `nickname`), `gender` = IFNULL(?, `gender`) WHERE `uid` = ?"
       _query = fmt.Sprintf(_query, LocateUserInfoTable(context_, appID))
       _args := []interface{}{args.Nickname, args.Gender, uid}
       return execer.ExecContext(context_, _query, _args...)
   }

   type UserInfo struct {
       UID      int64
       Nickname string
       Gender   int8
   }

   type UpdateUserInfoArgs struct {
       Nickname sql.NullString
       Gender   sql.NullInt64
   }

   ```


