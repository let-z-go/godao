# godao

DAO Generator for Go

## Requirements

- python 2/3

## Installation

```bash
pip install -U git+https://github.com/let-z-go/godao
```

## Usage examples

1. Define DAO with YAML (`sample.yaml`):

   ```yaml
   package_name: main
   
   $UserDAO:
     strings:
       $TableUserInfo:
         maker_func_name: LocateUserInfoTable
   
     $InsertUserInfo:
       input:
         $appID: string
         $uid: int64
         $nickname: string
         $gender: int8
       sql: |
         INSERT INTO
           `%s{str:TableUserInfo(appID)}` (`uid`, `nickname`, `gender`)
         VALUES
           (?{in:uid}, ?{in:nickname}, ?{in:gender})
   
     $SelectUserInfo:
       input:
         $appID: string
         $uid: int64
       output: &user_info_struct
         $UID: int64
         $Nickname: string
         $Gender: int8
         struct_type_name: UserInfo
         select_one: true
         ignore_no_rows: true
       sql: |
         SELECT
           `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
         FROM
           `%s{str:TableUserInfo(appID)}`
         WHERE
           `uid` = ?{in:uid}
   
     $SelectMultiUserInfos:
       input:
         $appID: string
         $uids: int64[]
       output:
         <<: *user_info_struct
         select_one: false
       sql: |
         SELECT
           `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
         FROM
           `%s{str:TableUserInfo(appID)}`
         WHERE
           `uid` IN (?{in:uids})
   
     $SelectNicknameFromUserInfo:
       input:
         $appID: string
         $uid: int64
       output:
         $nickname: string
         select_one: true
       sql: |
         SELECT
           `nickname{out:nickname}`
         FROM
           `%s{str:TableUserInfo(appID)}`
         WHERE
           `uid` = ?{in:uid}
   ```

2. Generate DAO code

   ```bash
   godao < sample.yaml > sample.go
   ```

3. What you got (`sample.go`):

   ```go
   /*
    * Generated by Godao. DO NOT EDIT!
    */
   
   package main
   
   import (
   	"context"
   	"database/sql"
   	"fmt"
   	"time"
   
   	"github.com/jmoiron/sqlx"
   )
   
   var (
   	_ = fmt.Sprintf
   	_ time.Time
   )
   
   type UserDAO struct {
   	db *sqlx.DB
   }
   
   func (self UserDAO) Tx(context_ context.Context, txOptions *sql.TxOptions, callback func(UserDAOTx) error) error {
   	tx, e := self.db.BeginTxx(context_, txOptions)
   
   	if e != nil {
   		return e
   	}
   
   	txIsCommitted := false
   
   	defer func() {
   		if !txIsCommitted {
   			tx.Rollback()
   		}
   	}()
   
   	if e := callback(UserDAOTx(tx)); e != nil {
   		return e
   	}
   
   	if e := tx.Commit(); e != nil {
   		return e
   	}
   
   	txIsCommitted = true
   	return nil
   }
   
   type UserDAOTx *sqlx.Tx
   
   func MakeUserDAO(db *sqlx.DB) UserDAO {
   	return UserDAO{db}
   }
   
   func (self UserDAO) InsertUserInfo(context_ context.Context, appID string, uid int64, nickname string, gender int8) (sql.Result, error) {
   	return self.doInsertUserInfo(self.db, context_, appID, uid, nickname, gender)
   }
   
   func (self UserDAO) TxInsertUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64, nickname string, gender int8) (sql.Result, error) {
   	return self.doInsertUserInfo((*sqlx.Tx)(tx), context_, appID, uid, nickname, gender)
   }
   
   func (UserDAO) doInsertUserInfo(execer sqlx.ExecerContext, context_ context.Context, appID string, uid int64, nickname string, gender int8) (sql.Result, error) {
   	/*
   	 * INSERT INTO
   	 *   `%s{str:TableUserInfo(appID)}` (`uid`, `nickname`, `gender`)
   	 * VALUES
   	 *   (?{in:uid}, ?{in:nickname}, ?{in:gender})
   	 */
   	query := "INSERT INTO `%s` (`uid`, `nickname`, `gender`) VALUES (?, ?, ?)"
   	query = fmt.Sprintf(query, LocateUserInfoTable(context_, appID))
   	args := []interface{}{uid, nickname, gender}
   	return execer.ExecContext(context_, query, args...)
   }
   
   type UserInfo struct {
   	UID      int64
   	Nickname string
   	Gender   int8
   }
   
   func (self UserDAO) SelectUserInfo(context_ context.Context, appID string, uid int64) (*UserInfo, error) {
   	return self.doSelectUserInfo(self.db, context_, appID, uid)
   }
   
   func (self UserDAO) TxSelectUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64) (*UserInfo, error) {
   	return self.doSelectUserInfo((*sqlx.Tx)(tx), context_, appID, uid)
   }
   
   func (UserDAO) doSelectUserInfo(queryer sqlx.QueryerContext, context_ context.Context, appID string, uid int64) (*UserInfo, error) {
   	/*
   	 * SELECT
   	 *   `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
   	 * FROM
   	 *   `%s{str:TableUserInfo(appID)}`
   	 * WHERE
   	 *   `uid` = ?{in:uid}
   	 */
   	query := "SELECT `uid`, `nickname`, `gender` FROM `%s` WHERE `uid` = ?"
   	query = fmt.Sprintf(query, LocateUserInfoTable(context_, appID))
   	args := []interface{}{uid}
   	row := queryer.QueryRowxContext(context_, query, args...)
   	var record UserInfo
   
   	if e := row.Scan(&record.UID, &record.Nickname, &record.Gender); e != nil {
   		if e == sql.ErrNoRows {
   			e = nil
   		}
   
   		return nil, e
   	}
   
   	return &record, nil
   }
   
   func (self UserDAO) SelectMultiUserInfos(context_ context.Context, appID string, uids []int64) ([]*UserInfo, error) {
   	return self.doSelectMultiUserInfos(self.db, context_, appID, uids)
   }
   
   func (self UserDAO) TxSelectMultiUserInfos(tx UserDAOTx, context_ context.Context, appID string, uids []int64) ([]*UserInfo, error) {
   	return self.doSelectMultiUserInfos((*sqlx.Tx)(tx), context_, appID, uids)
   }
   
   func (UserDAO) doSelectMultiUserInfos(queryer sqlx.QueryerContext, context_ context.Context, appID string, uids []int64) ([]*UserInfo, error) {
   	/*
   	 * SELECT
   	 *   `uid{out:UID}`, `nickname{out:Nickname}`, `gender{out:Gender}`
   	 * FROM
   	 *   `%s{str:TableUserInfo(appID)}`
   	 * WHERE
   	 *   `uid` IN (?{in:uids})
   	 */
   	query := "SELECT `uid`, `nickname`, `gender` FROM `%s` WHERE `uid` IN (?)"
   	query = fmt.Sprintf(query, LocateUserInfoTable(context_, appID))
   	args := []interface{}{uids}
   	query, args, e := sqlx.In(query, args...)
   
   	if e != nil {
   		return nil, e
   	}
   
   	rows, e := queryer.QueryxContext(context_, query, args...)
   
   	if e != nil {
   		return nil, e
   	}
   
   	records := []*UserInfo(nil)
   
   	for rows.Next() {
   		var record UserInfo
   
   		if e := rows.Scan(&record.UID, &record.Nickname, &record.Gender); e != nil {
   			rows.Close()
   			return nil, e
   		}
   
   		records = append(records, &record)
   	}
   
   	rows.Close()
   	return records, nil
   }
   
   func (self UserDAO) SelectNicknameFromUserInfo(context_ context.Context, appID string, uid int64) (string, error) {
   	return self.doSelectNicknameFromUserInfo(self.db, context_, appID, uid)
   }
   
   func (self UserDAO) TxSelectNicknameFromUserInfo(tx UserDAOTx, context_ context.Context, appID string, uid int64) (string, error) {
   	return self.doSelectNicknameFromUserInfo((*sqlx.Tx)(tx), context_, appID, uid)
   }
   
   func (UserDAO) doSelectNicknameFromUserInfo(queryer sqlx.QueryerContext, context_ context.Context, appID string, uid int64) (string, error) {
   	/*
   	 * SELECT
   	 *   `nickname{out:nickname}`
   	 * FROM
   	 *   `%s{str:TableUserInfo(appID)}`
   	 * WHERE
   	 *   `uid` = ?{in:uid}
   	 */
   	query := "SELECT `nickname` FROM `%s` WHERE `uid` = ?"
   	query = fmt.Sprintf(query, LocateUserInfoTable(context_, appID))
   	args := []interface{}{uid}
   	row := queryer.QueryRowxContext(context_, query, args...)
   	var record string
   
   	if e := row.Scan(&record); e != nil {
   		return "", e
   	}
   
   	return record, nil
   }
   ```

   